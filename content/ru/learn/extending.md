# Расширение

Flight разработан как расширяемый фреймворк. Фреймворк поставляется с набором
умолчаний методов и компонентов, но позволяет вам сопоставлять ваши собственные методы,
регистрировать свои классы или даже переопределять существующие классы и методы.

Если вы ищете DIC (Контейнер Внедрения Зависимостей), перейдите на страницу
[Контейнер Внедрения Зависимостей](dependency-injection-container).

## Сопоставление методов

Чтобы сопоставить ваш собственный простой пользовательский метод, используйте функцию `map`:

```php
// Сопоставьте ваш метод
Flight::map('hello', function (string $name) {
  echo "hello $name!";
});

// Вызовите ваш пользовательский метод
Flight::hello('Bob');
```

Хотя возможно создать простые пользовательские методы, рекомендуется просто создать
стандартные функции в PHP. Это обладает автозаполнением в IDE и проще для чтения.
Эквивалент приведенного выше кода будет:

```php
function hello(string $name) {
  echo "hello $name!";
}

hello('Bob');
```

Это используется чаще, когда вам нужно передать переменные в ваш метод, чтобы получить ожидаемое
значение. Использование метода `register()` как ниже больше предназначено для передачи конфигурации
и последующего вызова вашего заранее сконфигурированного класса.

## Регистрация классов

Чтобы зарегистрировать свой класс и настроить его, вы используете функцию `register`:

```php
// Зарегистрируйте ваш класс
Flight::register('user', User::class);

// Получите экземпляр вашего класса
$user = Flight::user();
```

Метод регистрации также позволяет передавать параметры в конструктор вашего класса.
Таким образом, когда вы загружаете ваш пользовательский класс, он будет предварительно инициализирован.
Вы можете определить параметры конструктора, передав дополнительный массив.
Вот пример загрузки подключения к базе данных:

```php
// Зарегистрировать класс с параметрами конструктора
Flight::register('db', PDO::class, ['mysql:host=localhost;dbname=test', 'user', 'pass']);

// Получите экземпляр вашего класса
// Это создаст объект с заданными параметрами
//
// new PDO('mysql:host=localhost;dbname=test','user','pass');
//
$db = Flight::db();

// и если вам это понадобится позже в коде, просто вызовите тот же метод снова
class SomeController {
  public function __construct() {
	$this->db = Flight::db();
  }
}
```

Если вы передадите дополнительный параметр обратного вызова, он будет выполнен немедленно
после создания класса. Это позволяет вам выполнять любые процедуры настройки для вашего
нового объекта. Функция обратного вызова принимает один параметр, экземпляр нового объекта.

```php
// Обратному вызову будет передан объект, который был построен
Flight::register(
  'db',
  PDO::class,
  ['mysql:host=localhost;dbname=test', 'user', 'pass'],
  function (PDO $db) {
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  }
);
```

По умолчанию каждый раз, когда вы загружаете свой класс, вы получаете общий экземпляр.
Чтобы получить новый экземпляр класса, просто передайте `false` в качестве параметра:

```php
// Общий экземпляр класса
$shared = Flight::db();

// Новый экземпляр класса
$new = Flight::db(false);
```

Имейте в виду, что сопоставленные методы имеют преимущество над зарегистрированными классами. Если вы
объявите оба с одним и тем же именем, будет вызван только сопоставленный метод.

## Логирование

Flight не имеет встроенной системы логирования, однако, очень легко
использовать библиотеку логирования с Flight. Вот пример, использующий библиотеку Monolog:

```php
// index.php или bootstrap.php

// Зарегистрируйте логгер с Flight
Flight::register('log', Monolog\Logger::class, [ 'name' ], function(Monolog\Logger $log) {
    $log->pushHandler(new Monolog\Handler\StreamHandler('path/to/your.log', Monolog\Logger::WARNING));
});
```

Теперь, когда он зарегистрирован, вы можете использовать его в своем приложении:

```php
// В вашем контроллере или маршруте
Flight::log()->warning('Это сообщение предупреждения');
```

Это зарегистрирует сообщение в файле журнала, который вы указали. Что делать, если вы хотите записать что-то, когда
возникает ошибка? Вы можете использовать метод `error`:

```php
// В вашем контроллере или маршруте

Flight::map('error', function(Throwable $ex) {
	Flight::log()->error($ex->getMessage());
	// Отобразите свою пользовательскую страницу ошибки
	include 'errors/500.html';
});
```

Вы также могли бы создать базовую систему APM (Мониторинг Производительности Приложений)
с помощью методов `before` и `after`:

```php
// В вашем файле начальной загрузки

Flight::before('start', function() {
	Flight::set('start_time', microtime(true));
});

Flight::after('start', function() {
	$end = microtime(true);
	$start = Flight::get('start_time');
	Flight::log()->info('Запрос '.Flight::request()->url.' занял ' . round($end - $start, 4) . ' секунд');

	// Вы также можете добавить свои заголовки запроса или ответа
	// чтобы зарегистрировать их (осторожно, так как это будет 
	// много данных, если у вас много запросов)
	Flight::log()->info('Заголовки запроса: ' . json_encode(Flight::request()->headers));
	Flight::log()->info('Заголовки ответа: ' . json_encode(Flight::response()->headers));
});
```

## Переопределение методов фреймворка

Flight позволяет вам переопределять его функциональность по умолчанию в соответствии с вашими собственными потребностями,
не модифицируя код. Вы можете просмотреть все методы, которые вы можете переопределить [здесь](/learn/api).

Например, когда Flight не может сопоставить URL с маршрутом, он вызывает метод `notFound`,
который отправляет общий ответ `HTTP 404`. Вы можете переопределить это поведение,
используя метод `map`:

```php
Flight::map('notFound', function() {
  // Отобразите пользовательскую страницу 404
  include 'errors/404.html';
});
```

Flight также позволяет вам заменять основные компоненты фреймворка.
Например, вы можете заменить класс Router по умолчанию своим собственным пользовательским классом:

```php
// Зарегистрируйте ваш пользовательский класс
Flight::register('router', MyRouter::class);

// Когда Flight загружает экземпляр Router, он загрузит ваш класс
$myrouter = Flight::router();
```

Методы фреймворка, такие как `map` и `register`, однако не могут быть переопределены. Вы получите ошибку,
если попытаетесь это сделать.