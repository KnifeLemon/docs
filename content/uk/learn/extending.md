# Розширення

Flight розроблений як розширювальний фреймворк. Фреймворк постачається з набором
за замовчуванням методів та компонентів, але дозволяє вам відображати свої власні методи,
реєструвати свої власні класи або навіть перевизначати існуючі класи та методи.

Якщо ви шукаєте DIC (Контейнер впровадження залежностей), перейдіть на
[Сторінка контейнера впровадження залежностей](dependency-injection-container).

## Відображення методів

Щоб відобразити свій власний простий кастомний метод, використовуйте функцію `map`:

```php
// Відобразіть свій метод
Flight::map('hello', function (string $name) {
  echo "привіт $name!";
});

// Викличте свій кастомний метод
Flight::hello('Боб');
```

Хоча можливо створити прості кастомні методи, рекомендується просто створювати
стандартні функції в PHP. Це має автозаповнення в IDE і легше читається.
Еквівалентом наведеного вище коду буде:

```php
function hello(string $name) {
  echo "привіт $name!";
}

hello('Боб');
```

Це використовується більше, коли вам потрібно передати змінні у ваш метод, щоб отримати очікуване
значення. Використання методу `register()` як наведено нижче більше підходить для передачі конфігурацій
і потім виклику вашого попередньо налаштованого класу.

## Реєстрація класів

Щоб зареєструвати свій власний клас і налаштувати його, використовуйте функцію `register`:

```php
// Зареєструйте свій клас
Flight::register('user', User::class);

// Отримайте екземпляр свого класу
$user = Flight::user();
```

Метод реєстрації також дозволяє вам передавати параметри в конструктор вашого класу.
Отже, коли ви завантажуєте свій кастомний клас, він буде попередньо ініціалізований.
Ви можете визначити параметри конструктора, передавши додатковий масив.
Ось приклад завантаження з'єднання з базою даних:

```php
// Зареєструйте клас з параметрами конструктора
Flight::register('db', PDO::class, ['mysql:host=localhost;dbname=test', 'user', 'pass']);

// Отримайте екземпляр свого класу
// Це створить об'єкт з визначеними параметрами
//
// new PDO('mysql:host=localhost;dbname=test','user','pass');
//
$db = Flight::db();

// і якщо вам це знадобиться пізніше у вашому коді, ви просто знову викликаєте той же метод
class SomeController {
  public function __construct() {
	$this->db = Flight::db();
  }
}
```

Якщо ви передасте додатковий параметр зворотного виклику, він буде виконаний негайно
після конструкції класу. Це дозволяє вам виконати будь-які процедури налаштування для вашого
нового об'єкта. Функція зворотного виклику приймає один параметр, екземпляр нового об'єкта.

```php
// Зворотний виклик отримає об'єкт, що був сконструйований
Flight::register(
  'db',
  PDO::class,
  ['mysql:host=localhost;dbname=test', 'user', 'pass'],
  function (PDO $db) {
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  }
);
```

За замовчуванням, кожного разу, коли ви завантажуєте свій клас, ви отримуєте спільний екземпляр.
Щоб отримати новий екземпляр класу, просто передайте `false` як параметр:

```php
// Спільний екземпляр класу
$shared = Flight::db();

// Новий екземпляр класу
$new = Flight::db(false);
```

Пам'ятайте, що відображені методи мають пріоритет над зареєстрованими класами. Якщо ви
оголосите обидва, використовуючи одне й те ж ім'я, буде викликано лише відображений метод.

## Логування

Flight не має вбудованої системи логування, однак, досить легко
використовувати бібліотеку логування з Flight. Ось приклад, що використовує бібліотеку Monolog:

```php
// index.php або bootstrap.php

// Зареєструйте логгер з Flight
Flight::register('log', Monolog\Logger::class, [ 'name' ], function(Monolog\Logger $log) {
    $log->pushHandler(new Monolog\Handler\StreamHandler('path/to/your.log', Monolog\Logger::WARNING));
});
```

Тепер, коли він зареєстрований, ви можете використовувати його у вашій програмі:

```php
// У вашому контролері або маршруті
Flight::log()->warning('Це повідомлення про попередження');
```

Це запише повідомлення у файл журналу, який ви вказали. Що якщо ви хочете зафіксувати щось, коли відбувається помилка? Ви можете використовувати метод `error`:

```php
// У вашому контролері або маршруті

Flight::map('error', function(Throwable $ex) {
	Flight::log()->error($ex->getMessage());
	// Відобразіть свою кастомну сторінку помилки
	include 'errors/500.html';
});
```

Ви також можете створити базову систему APM (Моніторинг продуктивності додатка), використовуючи методи `before` та `after`:

```php
// У вашому файлі старту

Flight::before('start', function() {
	Flight::set('start_time', microtime(true));
});

Flight::after('start', function() {
	$end = microtime(true);
	$start = Flight::get('start_time');
	Flight::log()->info('Запит '.Flight::request()->url.' тривав ' . round($end - $start, 4) . ' секунд');

	// Ви також можете додати свої заголовки запиту або відповіді
	// щоб зафіксувати їх (будьте обережні, бо це буде 
	// багато даних, якщо у вас багато запитів)
	Flight::log()->info('Заголовки запиту: ' . json_encode(Flight::request()->headers));
	Flight::log()->info('Заголовки відповіді: ' . json_encode(Flight::response()->headers));
});
```

## Перевизначення методів фреймворку

Flight дозволяє вам перевизначати свою стандартну функціональність відповідно до ваших потреб,
не вносячи зміни в код. Ви можете переглянути всі методи, які можете перевизначити [тут](/learn/api).

Наприклад, коли Flight не може співвіднести URL з маршрутом, він викликає метод `notFound`,
який надсилає загальний `HTTP 404` відповідь. Ви можете перевизначити цю поведінку
за допомогою методу `map`:

```php
Flight::map('notFound', function() {
  // Відобразіть кастомну 404 сторінку
  include 'errors/404.html';
});
```

Flight також дозволяє вам замінити основні компоненти фреймворку.
Наприклад, ви можете замінити стандартний клас Router своїм кастомним класом:

```php
// Зареєструйте свій кастомний клас
Flight::register('router', MyRouter::class);

// Коли Flight завантажує екземпляр Router, він завантажить ваш клас
$myrouter = Flight::router();
```

Методи фреймворку, такі як `map` та `register`, однак не можуть бути перевизначені. Ви отримаєте помилку, якщо спробуєте це зробити.