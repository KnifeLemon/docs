# Расширение

Flight предназначен для того, чтобы быть расширяемым фреймворком. Фреймворк поставляется с набором
стандартных методов и компонентов, но он позволяет вам сопоставлять свои собственные методы,
регистрировать свои собственные классы или даже переопределять существующие классы и методы.

Если вы ищете DIC (Контейнер Для Внедрения Зависимостей), переходите на страницу
[Контейнер Для Внедрения Зависимостей](dependency-injection-container).

## Сопоставление методов

Чтобы сопоставить свой собственный простой метод, вы используете функцию `map`:

```php
// Сопоставьте свой метод
Flight::map('hello', function (string $name) {
  echo "hello $name!";
});

// Вызовите свой собственный метод
Flight::hello('Bob');
```

Хотя сделать простые пользовательские методы возможно, настоятельно рекомендуется просто создавать
стандартные функции в PHP. Это имеет автозаполнение в IDE и легче читается.
Эквивалент приведённого выше кода будет:

```php
function hello(string $name) {
  echo "hello $name!";
}

hello('Bob');
```

Это используется больше, когда вам нужно передать переменные в ваш метод, чтобы получить ожидаемое
значение. Использование метода `register()`, как показано ниже, больше для передачи конфигурации
и последующего вызова вашего предварительно настроенного класса.

## Регистрация классов

Чтобы зарегистрировать свой собственный класс и настроить его, вы используете функцию `register`:

```php
// Зарегистрируйте ваш класс
Flight::register('user', User::class);

// Получите экземпляр вашего класса
$user = Flight::user();
```

Метод регистрации также позволяет вам передавать параметры в конструктор вашего класса.
Таким образом, когда вы загружаете свой пользовательский класс, он будет предварительно инициализирован.
Вы можете определить параметры конструктора, передав дополнительный массив.
Вот пример загрузки соединения с базой данных:

```php
// Зарегистрируйте класс с параметрами конструктора
Flight::register('db', PDO::class, ['mysql:host=localhost;dbname=test', 'user', 'pass']);

// Получите экземпляр вашего класса
// Это создаст объект с определёнными параметрами
//
// new PDO('mysql:host=localhost;dbname=test','user','pass');
//
$db = Flight::db();

// и если вам это понадобится позже в вашем коде, вы просто снова вызываете тот же метод
class SomeController {
  public function __construct() {
	$this->db = Flight::db();
  }
}
```

Если вы передадите дополнительный параметр обратного вызова, он будет выполнен немедленно
после создания класса. Это позволяет вам выполнять любые процедуры настройки для вашего
нового объекта. Функция обратного вызова принимает один параметр, экземпляр нового объекта.

```php
// Обратный вызов будет передан объекту, который был создан
Flight::register(
  'db',
  PDO::class,
  ['mysql:host=localhost;dbname=test', 'user', 'pass'],
  function (PDO $db) {
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  }
);
```

По умолчанию, каждый раз, когда вы загружаете ваш класс, вы получаете общий экземпляр.
Чтобы получить новый экземпляр класса, просто передайте `false` в качестве параметра:

```php
// Общий экземпляр класса
$shared = Flight::db();

// Новый экземпляр класса
$new = Flight::db(false);
```

Имейте в виду, что сопоставленные методы имеют приоритет над зарегистрированными классами. Если вы
объявите оба с тем же именем, будет вызван только сопоставленный метод.

## Ведение журнала

Flight не имеет встроенной системы ведения журналов, однако, использовать библиотеку ведения журналов с Flight очень просто. Вот пример использования библиотеки Monolog:

```php
// index.php или bootstrap.php

// Зарегистрируйте логгер с Flight
Flight::register('log', Monolog\Logger::class, [ 'name' ], function(Monolog\Logger $log) {
    $log->pushHandler(new Monolog\Handler\StreamHandler('path/to/your.log', Monolog\Logger::WARNING));
});
```

Теперь, когда он зарегистрирован, вы можете использовать его в своём приложении:

```php
// В вашем контроллере или маршруте
Flight::log()->warning('Это сообщение предупреждения');
```

Это зафиксирует сообщение в файл журнала, который вы указали. А что, если вы хотите зафиксировать что-то, когда происходит ошибка? Вы можете использовать метод `error`:

```php
// В вашем контроллере или маршруте

Flight::map('error', function(Throwable $ex) {
	Flight::log()->error($ex->getMessage());
	// Отобразите свою пользовательскую страницу ошибки
	include 'errors/500.html';
});
```

Вы также можете создать базовую систему APM (Мониторинг Производительности Приложения)
используя методы `before` и `after`:

```php
// В вашем bootstrap файле

Flight::before('start', function() {
	Flight::set('start_time', microtime(true));
});

Flight::after('start', function() {
	$end = microtime(true);
	$start = Flight::get('start_time');
	Flight::log()->info('Запрос '.Flight::request()->url.' занял ' . round($end - $start, 4) . ' секунд');

	// Вы также можете добавить свои заголовки запроса или ответа
	// чтобы зафиксировать их (будьте осторожны, так как это будет 
	// много данных, если у вас много запросов)
	Flight::log()->info('Заголовки запроса: ' . json_encode(Flight::request()->headers));
	Flight::log()->info('Заголовки ответа: ' . json_encode(Flight::response()->headers));
});
```

## Переопределение методов фреймворка

Flight позволяет вам переопределять его стандартную функциональность в соответствии с вашими потребностями,
не внося изменения в код. Вы можете просмотреть все методы, которые можно переопределить [здесь](/learn/api).

Например, когда Flight не может сопоставить URL с маршрутом, он вызывает метод `notFound`,
который отправляет общий ответ `HTTP 404`. Вы можете переопределить это поведение,
используя метод `map`:

```php
Flight::map('notFound', function() {
  // Отобразите пользовательскую страницу 404
  include 'errors/404.html';
});
```

Flight также позволяет вам заменять основные компоненты фреймворка.
Например, вы можете заменить класс Router по умолчанию на свой собственный пользовательский класс:

```php
// Зарегистрируйте свой собственный класс
Flight::register('router', MyRouter::class);

// Когда Flight загружает экземпляр Router, он загрузит ваш класс
$myrouter = Flight::router();
```

Однако методы фреймворка, такие как `map` и `register`, не могут быть переопределены. Вы получите ошибку, если попытаетесь это сделать.