# Менеджер событий

_начиная с v3.15.0_

## Обзор

События позволяют регистрировать и вызывать пользовательское поведение в вашем приложении. С добавлением `Flight::onEvent()` и `Flight::triggerEvent()` вы теперь можете подключаться к ключевым моментам жизненного цикла вашего приложения или определять свои собственные события (например, уведомления и emails), чтобы сделать ваш код более модульным и расширяемым. Эти методы являются частью [mappable methods](/learn/extending) в Flight, что означает, что вы можете переопределить их поведение в соответствии с вашими потребностями.

## Понимание

События позволяют разделять разные части вашего приложения, чтобы они не зависели друг от друга слишком сильно. Это разделение — часто называемое **decoupling** — делает ваш код проще для обновления, расширения или отладки. Вместо того чтобы писать всё в одном большом блоке, вы можете разделить логику на меньшие, независимые части, которые реагируют на конкретные действия (события).

Представьте, что вы строите приложение для блога:
- Когда пользователь публикует комментарий, вы можете захотеть:
  - Сохранить комментарий в базу данных.
  - Отправить email владельцу блога.
  - Записать действие для безопасности.

Без событий вы бы запихнули всё это в одну функцию. С событиями вы можете разделить: одна часть сохраняет комментарий, другая вызывает событие вроде `'comment.posted'`, а отдельные слушатели обрабатывают email и логирование. Это делает ваш код чище и позволяет добавлять или удалять функции (например, уведомления) без касания основной логики.

### Распространенные случаи использования

В основном события хороши для вещей, которые являются опциональными, но не абсолютной основной частью вашей системы. Например, следующие вещи хорошо иметь, но если они по какой-то причине не сработают, ваше приложение всё равно должно работать:

- **Логирование**: Записывать действия вроде входов или ошибок без засорения основного кода.
- **Уведомления**: Отправлять emails или оповещения, когда что-то происходит.
- **Обновления кэша**: Обновлять кэш или уведомлять другие системы об изменениях.

Однако, предположим, у вас есть функция "забыл пароль". Это должно быть частью вашей основной функциональности, а не событием, потому что если этот email не уйдёт, пользователь не сможет сбросить пароль и использовать ваше приложение.

## Базовое использование

Система событий Flight построена вокруг двух основных методов: `Flight::onEvent()` для регистрации слушателей событий и `Flight::triggerEvent()` для вызова событий. Вот как вы можете их использовать:

### Регистрация слушателей событий

Чтобы слушать событие, используйте `Flight::onEvent()`. Этот метод позволяет определить, что должно происходить, когда событие происходит.

```php
Flight::onEvent(string $event, callable $callback): void
```

- `$event`: Имя для вашего события (например, `'user.login'`).
- `$callback`: Функция, которая выполняется, когда событие вызывается.

Вы "подписываетесь" на событие, сообщая Flight, что делать, когда оно происходит. Callback может принимать аргументы, переданные от вызова события.

Система событий Flight синхронная, что означает, что каждый слушатель события выполняется последовательно, один за другим. Когда вы вызываете событие, все зарегистрированные слушатели для этого события выполнятся до завершения, прежде чем ваш код продолжится. Это важно понимать, поскольку это отличается от асинхронных систем событий, где слушатели могут выполняться параллельно или позже.

#### Простой пример
```php
Flight::onEvent('user.login', function ($username) {
    echo "Welcome back, $username!";

	// you can send an email if the login is from a new location
});
```
Здесь, когда событие `'user.login'` вызывается, оно приветствует пользователя по имени и может также включать логику для отправки email, если нужно.

> **Примечание:** Callback может быть функцией, анонимной функцией или методом из класса.

### Вызов событий

Чтобы событие произошло, используйте `Flight::triggerEvent()`. Это говорит Flight выполнить все слушатели, зарегистрированные для этого события, передавая любые данные, которые вы предоставите.

```php
Flight::triggerEvent(string $event, ...$args): void
```

- `$event`: Имя события, которое вы вызываете (должно соответствовать зарегистрированному событию).
- `...$args`: Опциональные аргументы для отправки слушателям (может быть любое количество аргументов).

#### Простой пример
```php
$username = 'alice';
Flight::triggerEvent('user.login', $username);
```
Это вызывает событие `'user.login'` и отправляет `'alice'` слушателю, который мы определили ранее, что выведет: `Welcome back, alice!`.

- Если слушатели не зарегистрированы, ничего не происходит — ваше приложение не сломается.
- Используйте spread operator (`...`) для гибкой передачи нескольких аргументов.

### Остановка событий

Если слушатель возвращает `false`, дополнительные слушатели для этого события не будут выполнены. Это позволяет остановить цепочку событий на основе конкретных условий. Помните, порядок слушателей имеет значение, поскольку первый, вернувший `false`, остановит остальные.

**Пример**:
```php
Flight::onEvent('user.login', function ($username) {
    if (isBanned($username)) {
        logoutUser($username);
        return false; // Stops subsequent listeners
    }
});
Flight::onEvent('user.login', function ($username) {
    sendWelcomeEmail($username); // this is never sent
});
```

### Переопределение методов событий

`Flight::onEvent()` и `Flight::triggerEvent()` доступны для [расширения](/learn/extending), что означает, что вы можете переопределить, как они работают. Это отлично для продвинутых пользователей, которые хотят кастомизировать систему событий, например, добавляя логирование или изменяя, как события диспетчеризуются.

#### Пример: Кастомизация `onEvent`
```php
Flight::map('onEvent', function (string $event, callable $callback) {
    // Log every event registration
    error_log("New event listener added for: $event");
    // Call the default behavior (assuming an internal event system)
    Flight::_onEvent($event, $callback);
});
```
Теперь каждый раз, когда вы регистрируете событие, оно логируется перед продолжением.

#### Почему переопределять?
- Добавить отладку или мониторинг.
- Ограничить события в определённых окружениях (например, отключить в тестировании).
- Интегрировать с другой библиотекой событий.

### Куда размещать события

Если вы новичок в концепциях событий в вашем проекте, вы можете задаться вопросом: *куда мне регистрировать все эти события в приложении?* Простота Flight означает, что нет строгого правила — вы можете размещать их там, где это имеет смысл для вашего проекта. Однако, поддерживая их организованными, вы помогаете поддерживать код по мере роста приложения. Вот несколько практических вариантов и лучших практик, адаптированных к лёгковесной природе Flight:

#### Вариант 1: В основном `index.php`
Для маленьких приложений или быстрых прототипов вы можете регистрировать события прямо в файле `index.php` рядом с маршрутами. Это держит всё в одном месте, что нормально, когда простота — ваш приоритет.

```php
require 'vendor/autoload.php';

// Register events
Flight::onEvent('user.login', function ($username) {
    error_log("$username logged in at " . date('Y-m-d H:i:s'));
});

// Define routes
Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Logged in!";
});

Flight::start();
```
- **Плюсы**: Просто, без лишних файлов, отлично для маленьких проектов.
- **Минусы**: Может стать беспорядочным по мере роста приложения с большим количеством событий и маршрутов.

#### Вариант 2: Отдельный файл `events.php`
Для чуть большего приложения рассмотрите перемещение регистраций событий в отдельный файл вроде `app/config/events.php`. Включите этот файл в `index.php` перед маршрутами. Это имитирует, как часто организуются маршруты в `app/config/routes.php` в проектах Flight.

```php
// app/config/events.php
Flight::onEvent('user.login', function ($username) {
    error_log("$username logged in at " . date('Y-m-d H:i:s'));
});

Flight::onEvent('user.registered', function ($email, $name) {
    echo "Email sent to $email: Welcome, $name!";
});
```

```php
// index.php
require 'vendor/autoload.php';
require 'app/config/events.php';

Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Logged in!";
});

Flight::start();
```
- **Плюсы**: Держит `index.php` сосредоточенным на маршрутизации, организует события логично, легко найти и редактировать.
- **Минусы**: Добавляет немного структуры, что может показаться излишним для очень маленьких приложений.

#### Вариант 3: Рядом с местом вызова
Другой подход — регистрировать события близко к месту их вызова, например, внутри контроллера или определения маршрута. Это хорошо работает, если событие специфично для одной части приложения.

```php
Flight::route('/signup', function () {
    // Register event here
    Flight::onEvent('user.registered', function ($email) {
        echo "Welcome email sent to $email!";
    });

    $email = 'jane@example.com';
    Flight::triggerEvent('user.registered', $email);
    echo "Signed up!";
});
```
- **Плюсы**: Держит связанный код вместе, хорошо для изолированных функций.
- **Минусы**: Разбрасывает регистрации событий, делая сложнее увидеть все события сразу; риск дублирования регистраций, если не осторожны.

#### Лучшая практика для Flight
- **Начните просто**: Для крошечных приложений размещайте события в `index.php`. Это быстро и соответствует минимализму Flight.
- **Растите умно**: По мере расширения приложения (например, больше 5-10 событий) используйте файл `app/config/events.php`. Это естественный шаг вверх, как организация маршрутов, и держит код аккуратным без добавления сложных фреймворков.
- **Избегайте переусложнения**: Не создавайте полноценный класс "event manager" или директорию, если приложение не огромно — Flight процветает на простоте, так что держите лёгковесно.

#### Совет: Группируйте по назначению
В `events.php` группируйте связанные события (например, все события, связанные с пользователем, вместе) с комментариями для ясности:

```php
// app/config/events.php
// User Events
Flight::onEvent('user.login', function ($username) {
    error_log("$username logged in");
});
Flight::onEvent('user.registered', function ($email) {
    echo "Welcome to $email!";
});

// Page Events
Flight::onEvent('page.updated', function ($pageId) {
    Flight::cache()->delete("page_$pageId");
});
```

Эта структура хорошо масштабируется и остаётся дружелюбной для новичков.

### Реальные примеры

Давайте пройдёмся по некоторым реальным сценариям, чтобы показать, как работают события и почему они полезны.

#### Пример 1: Логирование входа пользователя
```php
// Step 1: Register a listener
Flight::onEvent('user.login', function ($username) {
    $time = date('Y-m-d H:i:s');
    error_log("$username logged in at $time");
});

// Step 2: Trigger it in your app
Flight::route('/login', function () {
    $username = 'bob'; // Pretend this comes from a form
    Flight::triggerEvent('user.login', $username);
    echo "Hi, $username!";
});
```
**Почему полезно**: Код входа не нуждается в знании о логировании — он просто вызывает событие. Вы можете позже добавить больше слушателей (например, отправить приветственный email) без изменения маршрута.

#### Пример 2: Уведомление о новых пользователях
```php
// Listener for new registrations
Flight::onEvent('user.registered', function ($email, $name) {
    // Simulate sending an email
    echo "Email sent to $email: Welcome, $name!";
});

// Trigger it when someone signs up
Flight::route('/signup', function () {
    $email = 'jane@example.com';
    $name = 'Jane';
    Flight::triggerEvent('user.registered', $email, $name);
    echo "Thanks for signing up!";
});
```
**Почему полезно**: Логика регистрации сосредоточена на создании пользователя, в то время как событие обрабатывает уведомления. Вы можете добавить больше слушателей (например, логировать регистрацию) позже.

#### Пример 3: Очистка кэша
```php
// Listener to clear a cache
Flight::onEvent('page.updated', function ($pageId) {
	// if using the flightphp/cache plugin
    Flight::cache()->delete("page_$pageId");
    echo "Cache cleared for page $pageId.";
});

// Trigger when a page is edited
Flight::route('/edit-page/(@id)', function ($pageId) {
    // Pretend we updated the page
    Flight::triggerEvent('page.updated', $pageId);
    echo "Page $pageId updated.";
});
```
**Почему полезно**: Код редактирования не заботится о кэшировании — он просто сигнализирует об обновлении. Другие части приложения могут реагировать по необходимости.

### Лучшие практики

- **Называйте события ясно**: Используйте конкретные имена вроде `'user.login'` или `'page.updated'`, чтобы было очевидно, что они делают.
- **Держите слушателей простыми**: Не размещайте медленные или сложные задачи в слушателях — держите приложение быстрым.
- **Тестируйте события**: Вызывайте их вручную, чтобы убедиться, что слушатели работают как ожидается.
- **Используйте события разумно**: Они отличны для decoupling, но слишком много может сделать код сложным для отслеживания — используйте их, когда это имеет смысл.

Система событий в Flight PHP с `Flight::onEvent()` и `Flight::triggerEvent()` даёт вам простой, но мощный способ строить гибкие приложения. Позволяя разным частям приложения общаться друг с другом через события, вы можете держать код организованным, переиспользуемым и простым для расширения. Будь то логирование действий, отправка уведомлений или управление обновлениями, события помогают делать это без запутывания логики. Плюс, с возможностью переопределения этих методов, у вас есть свобода адаптировать систему под ваши нужды. Начните с одного события и посмотрите, как оно трансформирует структуру вашего приложения!

### Встроенные события

Flight PHP поставляется с несколькими встроенными событиями, которые вы можете использовать для подключения к жизненному циклу фреймворка. Эти события вызываются в конкретных точках цикла запрос/ответ, позволяя выполнять пользовательскую логику, когда происходят определённые действия.

#### Список встроенных событий
- **flight.request.received**: `function(Request $request)` Вызывается, когда запрос получен, разобраны и обработан.
- **flight.error**: `function(Throwable $exception)` Вызывается, когда происходит ошибка во время жизненного цикла запроса.
- **flight.redirect**: `function(string $url, int $status_code)` Вызывается, когда инициируется перенаправление.
- **flight.cache.checked**: `function(string $cache_key, bool $hit, float $executionTime)` Вызывается, когда кэш проверяется для конкретного ключа и попадание или промах в кэш.
- **flight.middleware.before**: `function(Route $route)`Вызывается после выполнения middleware before.
- **flight.middleware.after**: `function(Route $route)` Вызывается после выполнения middleware after.
- **flight.middleware.executed**: `function(Route $route, $middleware, string $method, float $executionTime)` Вызывается после выполнения любого middleware
- **flight.route.matched**: `function(Route $route)` Вызывается, когда маршрут совпадает, но ещё не запущен.
- **flight.route.executed**: `function(Route $route, float $executionTime)` Вызывается после выполнения и обработки маршрута. `$executionTime` — время, потраченное на выполнение маршрута (вызов контроллера и т.д.).
- **flight.view.rendered**: `function(string $template_file_path, float $executionTime)` Вызывается после рендеринга вида. `$executionTime` — время, потраченное на рендеринг шаблона. **Примечание: Если вы переопределите метод `render`, вам нужно будет повторно вызвать это событие.**
- **flight.response.sent**: `function(Response $response, float $executionTime)` Вызывается после отправки ответа клиенту. `$executionTime` — время, потраченное на построение ответа.

## См. также
- [Extending Flight](/learn/extending) - Как расширять и кастомизировать основную функциональность Flight.
- [Cache](/awesome-plugins/php_file_cache) - Пример использования событий для очистки кэша при обновлении страницы.

## Устранение неисправностей
- Если вы не видите, что ваши слушатели событий вызываются, убедитесь, что регистрируете их перед вызовом событий. Порядок регистрации имеет значение.

## Журнал изменений
- v3.15.0 - Добавлены события в Flight.