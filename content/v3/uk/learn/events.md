# Система подій у Flight PHP (v3.15.0+)

Flight PHP вводить легку та інтуїтивно зрозумілу систему подій, яка дозволяє вам реєструвати та активувати власні події у вашій програмі. З додаванням `Flight::onEvent()` та `Flight::triggerEvent()`, ви тепер можете підключатися до ключових моментів життєвого циклу вашого додатку або визначати свої власні події, щоб зробити ваш код більш модульним та розширювальним. Ці методи є частиною **відображуваних методів** Flight, що означає, що ви можете перевизначити їх поведінку відповідно до ваших потреб.

Цей посібник охоплює все, що вам потрібно знати, щоб почати працювати з подіями, включаючи чому вони цінні, як їх використовувати та практичні приклади, щоб допомогти новачкам зрозуміти їхню силу.

## Чому варто використовувати події?

Події дозволяють вам розділити різні частини вашого додатку так, щоб вони не залежали занадто сильно один від одного. Це розділення — часто називане **декуплінгом** — робить ваш код легшим для оновлення, розширення чи налагодження. Замість того, щоб писати все в одному великому шматку, ви можете розділити вашу логіку на менші, незалежні частини, які реагують на конкретні дії (події).

Уявіть, що ви розробляєте додаток для блогу:
- Коли користувач залишає коментар, ви можливо захочете:
  - Зберегти коментар у базі даних.
  - Відправити електронний лист власнику блогу.
  - Залоги приводу для безпеки.

Без подій, ви б змусили все це в одну функцію. З подіями, ви можете розділити це: одна частина зберігає коментар, інша активує подію на кшталт `'comment.posted'`, а окремі слухачі обробляють електронну пошту та логування. Це зберігає ваш код чистішим та дозволяє вам додавати або видаляти функції (як-от сповіщення) без втручання в основну логіку.

### Загальні застосування
- **Логування**: Записуйте дії, такі як входи або помилки, не заважаючи вашому основному коду.
- **Сповіщення**: Відправляйте електронні листи або сповіщення, коли щось відбувається.
- **Оновлення**: Оновлюйте кеш або сповіщайте інші системи про зміни.

## Реєстрація слухачів подій

Щоб прослухати подію, використовуйте `Flight::onEvent()`. Цей метод дозволяє вам визначити, що повинно відбутися, коли подія виникає.

### Синтаксис
```php
Flight::onEvent(string $event, callable $callback): void
```
- `$event`: Назва вашої події (наприклад, `'user.login'`).
- `$callback`: Функція, яка виконується, коли подія активується.

### Як це працює
Ви "підписуєтеся" на подію, кажучи Flight, що робити, коли це відбувається. Колбек може приймати аргументи, передані з тригера події.

Система подій Flight є синхронною, що означає, що кожен слухач подій виконується в послідовності, один за одним. Коли ви активуєте подію, всі зареєстровані слухачі для цієї події будуть виконані до завершення, перш ніж ваш код продовжиться. Це важливо розуміти, оскільки це відрізняється від асинхронних систем подій, де слухачі можуть виконуватись паралельно або в пізніший час.

### Простий приклад
```php
Flight::onEvent('user.login', function ($username) {
    echo "Ласкаво просимо назад, $username!";
});
```
Тут, коли активується подія `'user.login'`, вона привітає користувача за іменем.

### Ключові моменти
- Ви можете додати кілька слухачів до однієї й тієї ж події — вони виконуватимуться в порядку, в якому ви їх зареєстрували.
- Колбек може бути функцією, анонімною функцією або методом класу.

## Активація подій

Щоб зробити подію активною, використовуйте `Flight::triggerEvent()`. Це говорить Flight виконати всіх слухачів, зареєстрованих для цієї події, передаючи будь-які дані, які ви надаєте.

### Синтаксис
```php
Flight::triggerEvent(string $event, ...$args): void
```
- `$event`: Назва події, яку ви активуєте (має відповідати зареєстрованій події).
- `...$args`: Опціональні аргументи для відправки слухачам (може бути будь-яка кількість аргументів).

### Простий приклад
```php
$username = 'alice';
Flight::triggerEvent('user.login', $username);
```
Це активує подію `'user.login'` і передає `'alice'` слухачу, якого ми визначили раніше, який виведе: `Ласкаво просимо назад, alice!`.

### Ключові моменти
- Якщо не зареєстровано слухачів, нічого не відбувається — ваш додаток не буде ламатися.
- Використовуйте оператор поширення (`...`), щоб гнучко передавати кілька аргументів.

### Реєстрація слухачів подій

...

**Зупинка подальших слухачів**:
Якщо слухач повертає `false`, жоден з наступних слухачів для цієї події не буде виконано. Це дозволяє вам зупинити ланцюг подій на основі конкретних умов. Пам'ятайте, що порядок слухачів має значення, оскільки перший, хто повертає `false`, зупинить решту від виконання.

**Приклад**:
```php
Flight::onEvent('user.login', function ($username) {
    if (isBanned($username)) {
        logoutUser($username);
        return false; // Зупиняє наступні слухачі
    }
});
Flight::onEvent('user.login', function ($username) {
    sendWelcomeEmail($username); // цей ніколи не буде надіслано
});
```

## Перевизначення методів подій

`Flight::onEvent()` та `Flight::triggerEvent()` доступні для [розширення](/learn/extending), що означає, що ви можете переозначити, як вони працюють. Це чудово підходить для просунутих користувачів, які хочуть налаштувати систему подій, наприклад, додати логування або змінити, як події передаються.

### Приклад: Налаштування `onEvent`
```php
Flight::map('onEvent', function (string $event, callable $callback) {
    // Логувати кожну реєстрацію події
    error_log("Додано новий слухач події для: $event");
    // Викликати стандартну поведінку (припускаючи внутрішню систему подій)
    Flight::_onEvent($event, $callback);
});
```
Тепер кожного разу, коли ви реєструєте подію, вона записується перед продовженням.

### Чому перевизначати?
- Додати налагодження або моніторинг.
- Обмежити події в певних середовищах (наприклад, вимкнути у тестуванні).
- Інтегруватися з іншою бібліотекою подій.

## Де розмістити ваші події

Як новачок, ви можете запитати: *де мені реєструвати всі ці події в моєму додатку?* Простота Flight означає, що немає суворих правил — ви можете помістити їх туди, де це має сенс для вашого проекту. Проте, збереження їх в організованому вигляді допоможе вам підтримувати ваш код в міру зростання вашого додатку. Ось кілька практичних варіантів і найкращих практик, адаптованих до легкості Flight:

### Варіант 1: У вашому основному `index.php`
Для невеликих додатків або швидких прототипів ви можете зареєструвати події прямо у вашому файлі `index.php`, поряд з вашими маршрутами. Це утримує все в одному місці, що є прийнятним, коли простота є вашим пріоритетом.

```php
require 'vendor/autoload.php';

// Реєстрація подій
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов о " . date('Y-m-d H:i:s'));
});

// Визначення маршрутів
Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Увійшов!";
});

Flight::start();
```
- **Плюси**: Просто, немає додаткових файлів, відмінно для невеликих проектів.
- **Мінуси**: Може стати неохайно, коли ваш додаток зростає з більшими подіями та маршрутами.

### Варіант 2: Окремий файл `events.php`
Для трохи більших додатків розгляньте можливість перенесення реєстрацій подій у спеціалізований файл, такий як `app/config/events.php`. Включіть цей файл у ваш `index.php` перед вашими маршрутами. Це імітує те, як маршрути часто організовані в `app/config/routes.php` у проектах Flight.

```php
// app/config/events.php
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов о " . date('Y-m-d H:i:s'));
});

Flight::onEvent('user.registered', function ($email, $name) {
    echo "Електронний лист надіслано на $email: Ласкаво просимо, $name!";
});
```

```php
// index.php
require 'vendor/autoload.php';
require 'app/config/events.php';

Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Увійшов!";
});

Flight::start();
```
- **Плюси**: Зберігає `index.php` зосередженим на маршрутизації, логічно організовує події, легко знаходити та редагувати.
- **Мінуси**: Додає трохи структури, що може відчуватися надмірно для дуже малих додатків.

### Варіант 3: Поруч з місцем, де їх активують
Ще один підхід - реєструвати події ближче до місця, де їх активують, наприклад, всередині контролера або визначення маршруту. Це добре працює, якщо подія специфічна для однієї частини вашого додатку.

```php
Flight::route('/signup', function () {
    // Реєструвати подію тут
    Flight::onEvent('user.registered', function ($email) {
        echo "Сповіщення надіслано на $email!";
    });

    $email = 'jane@example.com';
    Flight::triggerEvent('user.registered', $email);
    echo "Зареєстровано!";
});
```
- **Плюси**: Зберігає пов’язаний код разом, добре для ізольованих функцій.
- **Мінуси**: Розкидає реєстрації подій, ускладнюючи перегляд усіх подій одночасно; ризик дублікатів реєстрацій, якщо не бути уважним.

### Найкраща практика для Flight
- **Починайте з простоти**: Для крихітних додатків розмістіть події в `index.php`. Це швидко і відповідає мінімалізму Flight.
- **Розвивайтеся розумно**: Коли ваш додаток розширюється (наприклад, більше 5-10 подій), використовуйте файл `app/config/events.php`. Це природний крок уперед, як організація маршрутів, і утримує ваш код охайним без надмірного ускладнення.
- **Уникайте надмірної інженерії**: Не створюйте повноцінний "клас менеджера подій" або каталог, якщо ваш додаток не став величезним — Flight процвітає завдяки простоті, тому зберігайте його легким.

### Порада: Групуйте за метою
У `events.php`, групуйте пов’язані події (наприклад, всі події, пов’язані з користувачами, разом) з коментарями для чіткості:

```php
// app/config/events.php
// Події користувачів
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов");
});
Flight::onEvent('user.registered', function ($email) {
    echo "Ласкаво просимо до $email!";
});

// Події сторінок
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]);
});
```

Ця структура добре масштабується і залишається зрозумілою для новачків.

## Приклади для новачків

Давайте пройдемося через кілька реальних сценаріїв, щоб показати, як працюють події і чому вони корисні.

### Приклад 1: Логування входу користувача
```php
// Крок 1: Реєстрація слухача
Flight::onEvent('user.login', function ($username) {
    $time = date('Y-m-d H:i:s');
    error_log("$username увійшов о $time");
});

// Крок 2: Активуйте це у вашому додатку
Flight::route('/login', function () {
    $username = 'bob'; // Уявімо, що це приходить з форми
    Flight::triggerEvent('user.login', $username);
    echo "Привіт, $username!";
});
```
**Чому це корисно**: Код входу не повинен знати про логування — він просто активує подію. Ви можете пізніше додати більше слухачів (наприклад, відправити вітальний лист) без зміни маршруту.

### Приклад 2: Сповіщення про нових користувачів
```php
// Слухач для нових реєстрацій
Flight::onEvent('user.registered', function ($email, $name) {
    // Імітувати відправлення електронного листа
    echo "Електронний лист надіслано на $email: Ласкаво просимо, $name!";
});

// Активуйте це, коли хтось реєструється
Flight::route('/signup', function () {
    $email = 'jane@example.com';
    $name = 'Jane';
    Flight::triggerEvent('user.registered', $email, $name);
    echo "Дякуємо за реєстрацію!";
});
```
**Чому це корисно**: Логіка реєстрації зосереджена на створенні користувача, тоді як подія обробляє сповіщення. Ви могли б додати більше слухачів (наприклад, залогувати реєстрацію) пізніше.

### Приклад 3: Очистка кешу
```php
// Слухач для очищення кешу
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]); // Очистити кеш сесії, якщо це доречно
    echo "Кеш очищено для сторінки $pageId.";
});

// Активуйте це, коли сторінка редагується
Flight::route('/edit-page/(@id)', function ($pageId) {
    // Уявімо, що ми оновили сторінку
    Flight::triggerEvent('page.updated', $pageId);
    echo "Сторінка $pageId оновлена.";
});
```
**Чому це корисно**: Код редагування не повинен піклуватися про кешування — він просто сигналізує про оновлення. Інші частини програми можуть реагувати на це за потребою.

## Найкращі практики

- **Чітко називайте події**: Використовуйте специфічні назви, такі як `'user.login'` або `'page.updated'`, щоб було очевидно, що вони роблять.
- **Зберігайте слухачів простими**: Не ставте повільні або складні завдання в слухачах — зберігайте ваш додаток швидким.
- **Тестуйте ваші події**: Активуйте їх вручну, щоб переконатися, що слухачі працюють, як очікується.
- **Використовуйте події з розумом**: Вони чудово підходять для декуплінгу, але надто багато може ускладнити ваш код — використовуйте їх, коли це має сенс.

Система подій у Flight PHP, з `Flight::onEvent()` та `Flight::triggerEvent()`, дає вам простий, але потужний спосіб створювати гнучкі додатки. Дозволяючи різним частинам вашого додатку спілкуватися одне з одним через події, ви можете зберігати ваш код організованим, повторно використаним і легким для розширення. Чи ви логіруєте дії, надсилаєте сповіщення чи управляєте оновленнями, події допомагають вам робити це без заплутування вашої логіки. Більше того, з можливістю перевизначення цих методів, ви отримуєте свободу налаштувати систему під ваші потреби. Почніть з маленької події і спостерігайте, як вона трансформує структуру вашого додатку!

## Вбудовані події

Flight PHP поставляється з кількома вбудованими подіями, які ви можете використовувати для підключення до життєвого циклу фреймворку. Ці події активуються в певні моменти в циклі запит/відповідь, дозволяючи вам виконувати власну логіку, коли відбуваються певні дії.

### Список вбудованих подій
- `flight.request.received`: Активується, коли запит отримано, розпарсено та оброблено.
- `flight.route.middleware.before`: Активується, після того як виконано попереднє проміжне програмне забезпечення.
- `flight.route.middleware.after`: Активується, після того як виконано післяпроміжне програмне забезпечення.
- `flight.route.executed`: Активується після виконання та обробки маршруту.
- `flight.response.sent`: Активується після того, як відповідь надіслана клієнту.