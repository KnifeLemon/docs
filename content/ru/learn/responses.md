# Ответы

Flight помогает генерировать часть заголовков ответа для вас, но вы контролируете большую часть того, что вы отправляете обратно пользователю. Иногда вы можете получить доступ к объекту `Response` напрямую, но большую часть времени вы будете использовать экземпляр `Flight` для отправки ответа.

## Отправка базового ответа

Flight использует ob_start(), чтобы буферизовать вывод. Это означает, что вы можете использовать `echo` или `print` для отправки ответа пользователю, и Flight захватит его и отправит обратно пользователю с соответствующими заголовками.

```php

// Это отправит "Привет, мир!" в браузер пользователя
Flight::route('/', function() {
	echo "Привет, мир!";
});

// HTTP/1.1 200 OK
// Content-Type: text/html
//
// Привет, мир!
```

В качестве альтернативы, вы можете вызвать метод `write()`, чтобы добавить что-то в тело также.

```php

// Это отправит "Привет, мир!" в браузер пользователя
Flight::route('/', function() {
	// нудно, но иногда справляется, когда вам это нужно
	Flight::response()->write("Привет, мир!");

	// если вы хотите получить тело, которое вы установили на этом этапе
	// вы можете сделать это так
	$body = Flight::response()->getBody();
});
```

## Коды статусов

Вы можете установить код статуса ответа, используя метод `status`:

```php
Flight::route('/@id', function($id) {
	if($id == 123) {
		Flight::response()->status(200);
		echo "Привет, мир!";
	} else {
		Flight::response()->status(403);
		echo "Запрещено";
	}
});
```

Если вы хотите получить текущий код статуса, вы можете использовать метод `status` без аргументов:

```php
Flight::response()->status(); // 200
```

## Запуск обратного вызова на теле ответа

Вы можете запустить обратный вызов на теле ответа, используя метод `addResponseBodyCallback`:

```php
Flight::route('/пользователи', function() {
	$db = Flight::db();
	$users = $db->fetchAll("SELECT * FROM users");
	Flight::render('users_table', ['users' => $users]);
});

// Это сжимает все ответы для любого маршрута
Flight::response()->addResponseBodyCallback(function($body) {
	return gzencode($body, 9);
});
```

Вы можете добавить несколько обратных вызовов, и они будут запущены в порядке их добавления. Поскольку это может принимать любой [вызываемый объект](https://www.php.net/manual/ru/language.types.callable.php), он может принимать массив класса `[ $class, 'method' ]`, замыкание `$strReplace = function($body) { str_replace('hi', 'there', $body); };`, или имя функции `'minify'`, если у вас, например, есть функция для минификации вашего HTML-кода.

**Примечание:** Обратные вызовы маршрута не будут работать, если вы используете параметр конфигурации `flight.v2.output_buffering`.

### Отдельный обратный вызов маршрута

Если вы хотите, чтобы это применялось только к определенному маршруту, вы можете добавить обратный вызов в сам маршрут:

```php
Flight::route('/пользователи', function() {
	$db = Flight::db();
	$users = $db->fetchAll("SELECT * FROM users");
	Flight::render('users_table', ['users' => $users]);

	// Это сжимает только ответ для этого маршрута
	Flight::response()->addResponseBodyCallback(function($body) {
		return gzencode($body, 9);
	});
});
```

### Опция Middleware

Вы также можете использовать промежуточное программное обеспечение, чтобы применить обратный вызов ко всем маршрутам через промежуточное программное обеспечение:

```php
// MinifyMiddleware.php
class MinifyMiddleware {
	public function before() {
		Flight::response()->addResponseBodyCallback(function($body) {
			// Это 
			return $this->minify($body);
		});
	}

	protected function minify(string $body): string {
		// минимизировать тело
		return $body;
	}
}

// index.php
Flight::group('/пользователи', function() {
	Flight::route('', function() { /* ... */ });
	Flight::route('/@id', function($id) { /* ... */ });
}, [ new MinifyMiddleware() ]);
```

## Установка заголовка ответа

Вы можете установить заголовок, такой как тип содержимого ответа, используя метод `header`:

```php

// Это отправит "Привет, мир!" в браузер пользователя в виде обычного текста
Flight::route('/', function() {
	Flight::response()->header('Content-Type', 'text/plain');
	echo "Привет, мир!";
});
```

## JSON

Flight предоставляет поддержку для отправки JSON- и JSONP-ответов. Чтобы отправить JSON-ответ, вы
передаете некоторые данные для кодирования в JSON:

```php
Flight::json(['id' => 123]);
```

### JSON с кодом состояния

Вы также можете передать код состояния в качестве второго аргумента:

```php
Flight::json(['id' => 123], 201);
```

### JSON с красивым выводом

Вы также можете передать аргумент в последнюю позицию, чтобы включить красивый вывод:

```php
Flight::json(['id' => 123], 200, true, 'utf-8', JSON_PRETTY_PRINT);
```

Если вы изменяете параметры, передаваемые в `Flight::json()` и хотите более простый синтаксис, вы можете
просто переназначить метод JSON:

```php
Flight::map('json', function($data, $code = 200, $options = 0) {
	Flight::_json($data, $code, true, 'utf-8', $options);
}

// Теперь его можно использовать так
Flight::json(['id' => 123], 200, JSON_PRETTY_PRINT);
```

### JSON и остановка выполнения

Если вы хотите отправить JSON-ответ и прекратить выполнение, вы можете использовать метод `jsonHalt`.
Это полезно для случаев, когда вы проверяете, возможно, какой-то вид авторизации и если
пользователь не авторизован, вы можете немедленно отправить JSON-ответ, очистить текущее тело
содержимого и прекратить выполнение.

```php
Flight::route('/пользователи', function() {
	$authorized = someAuthorizationCheck();
	// Проверяем, авторизован ли пользователь
	if($authorized === false) {
		Flight::jsonHalt(['error' => 'Недопустимо'], 401);
	}

	// Продолжаем с остальной частью маршрута
});
```

### JSONP

Для запросов JSONP вы можете необязательно передать имя параметра запроса, которое вы
используете для определения функции обратного вызова:

```php
Flight::jsonp(['id' => 123], 'q');
```

Таким образом, сделав GET-запрос с использованием `?q=my_func`, вы должны получить вывод:

```javascript
my_func({"id":123});
```

Если вы не передаете имя параметра запроса, значение по умолчанию будет `jsonp`.

## Перенаправление на другой URL

Вы можете перенаправить текущий запрос, используя метод `redirect()` и передав
новый URL:

```php
Flight::redirect('/новое/местоположение');
```

По умолчанию Flight отправляет код состояния HTTP 303 ("Смотрите другое"). Вы также можете установить
пользовательский код:

```php
Flight::redirect('/новое/местоположение', 401);
```

## Остановка

Вы можете остановить работу фреймворка в любой момент, вызвав метод `halt`:

```php
Flight::halt();
```

Вы также можете указать необязательный `HTTP` код состояния и сообщение:

```php
Flight::halt(200, 'Скоро вернусь...');
```

Вызов метода `halt` приведет к отбрасыванию любого содержимого ответа до этого момента. Если вы хотите остановить
работу фреймворка и вывести текущий ответ, используйте метод `stop`:

```php
Flight::stop();
```

## HTTP-кэширование

Flight предоставляет встроенную поддержку кэширования на уровне HTTP. Если условие кэширования
выполняется, Flight вернет ответ HTTP `304 Not Modified`. В следующий раз
клиент запросит тот же ресурс, ему будет предложено использовать его локально
закэшированную версию.

### Кэширование на уровне маршрута

Если вы хотите закэшировать весь ваш ответ, вы можете использовать метод `cache()` и передать время кэширования.

```php

// Это закэширует ответ на 5 минут
Flight::route('/новости', function () {
  Flight::response()->cache(time() + 300);
  echo 'Это содержимое будет закэшировано.';
});

// Кроме того, вы можете использовать строку, которую вы бы передали
// методу strtotime()
Flight::route('/новости', function () {
  Flight::response()->cache('+5 минут');
  echo 'Это содержимое будет закэшировано.';
});
```

### Последнее изменение

Вы можете использовать метод `lastModified` и передать метку времени UNIX для установки даты
и времени последнего изменения страницы. Клиент будет продолжать использовать свой кеш до
тех пор, пока значение последнего изменения не изменится.

```php
Flight::route('/новости', function () {
  Flight::lastModified(1234567890);
  echo 'Это содержание будет закэшировано.';
});
```

### ETag

Кэширование `ETag` аналогично `Last-Modified`, за исключением того, что вы можете указать любой id для
ресурса:

```php
Flight::route('/новости', function () {
  Flight::etag('my-unique-id');
  echo 'Это содержание будет закэшировано.';
});
```

Имейте в виду, что вызов метода `lastModified` или `etag` и установка и проверка кэш-значения.
Если кэш-значение совпадает между запросами, Flight немедленно отправит
ответ `HTTP 304` и прекратит обработку.