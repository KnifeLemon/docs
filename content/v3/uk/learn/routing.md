# Маршрутизація

> **Примітка:** Хочете дізнатися більше про маршрутизацію? Перегляньте сторінку ["why a framework?"](/learn/why-frameworks) для більш детального пояснення.

Базова маршрутизація в Flight виконується шляхом відповідності шаблону URL зворотному виклику функції або масиву класу і методу.

```php
Flight::route('/', function(){
    echo 'hello world!';  // Це коментар, який пояснює, що виводить привітання
});
```

> Маршрути відповідають у порядку їх визначення. Перший маршрут, який відповідає запиту, буде викликаний.

### Зворотні виклики/Функції
Зворотний виклик може бути будь-яким об'єктом, який можна викликати. Отже, ви можете використовувати звичайну функцію:

```php
function hello() {
    echo 'hello world!';  // Ця функція виводить привітання
}

Flight::route('/', 'hello');
```

### Класи
Ви також можете використовувати статичний метод класу:

```php
class Greeting {
    public static function hello() {
        echo 'hello world!';  // Статичний метод для виведення привітання
    }
}

Flight::route('/', [ 'Greeting','hello' ]);
```

Або шляхом створення об'єкта спочатку, а потім виклику методу:

```php
// Greeting.php  // Файл класу привітання
class Greeting
{
    public function __construct() {
        $this->name = 'John Doe';  // Ініціалізація властивості з ім'ям
    }

    public function hello() {
        echo "Hello, {$this->name}!";  // Метод для виведення привітання з ім'ям
    }
}

// index.php  // Головний файл
$greeting = new Greeting();

Flight::route('/', [ $greeting, 'hello' ]);
// Ви також можете зробити це без створення об'єкта спочатку
// Примітка: Аргументи не будуть ін'єктовані в конструктор
Flight::route('/', [ 'Greeting', 'hello' ]);
// Крім того, ви можете використовувати цей коротший синтаксис
Flight::route('/', 'Greeting->hello');
// або
Flight::route('/', Greeting::class.'->hello');
```

#### Залежність через DIC (Контейнер ін'єкції залежностей)
Якщо ви хочете використовувати ін'єкцію залежностей через контейнер (PSR-11, PHP-DI, Dice тощо), єдиний тип маршрутів, де це доступно, - це безпосередньо створення об'єкта самостійно або використання рядків для визначення класу і методу для виклику. Ви можете перейти на сторінку [Dependency Injection](/learn/extending) для отримання більшої інформації.

Ось швидкий приклад:

```php
use flight\database\PdoWrapper;  // Імпорт класу для обгортки PDO

// Greeting.php  // Файл класу привітання
class Greeting
{
	protected PdoWrapper $pdoWrapper;
	public function __construct(PdoWrapper $pdoWrapper) {
		$this->pdoWrapper = $pdoWrapper;  // Присвоєння обгортки PDO
	}

	public function hello(int $id) {
		// Виконати щось з $this->pdoWrapper
		$name = $this->pdoWrapper->fetchField("SELECT name FROM users WHERE id = ?", [ $id ]);  // Отримання поля з бази даних
		echo "Hello, world! My name is {$name}!";  // Вивід привітання з ім'ям
	}
}

// index.php  // Головний файл

// Налаштування контейнера з необхідними параметрами
// Дивіться сторінку Dependency Injection для більшої інформації про PSR-11
$dice = new \Dice\Dice();

// Не забудьте переприсвоїти змінну з '$dice = '!!!!!
$dice = $dice->addRule('flight\database\PdoWrapper', [
	'shared' => true,  // Зробити об'єкт спільним
	'constructParams' => [ 
		'mysql:host=localhost;dbname=test', 
		'root',
		'password'
	]
]);

// Зареєструвати обробник контейнера
Flight::registerContainerHandler(function($class, $params) use ($dice) {
	return $dice->create($class, $params);  // Створення об'єкта через контейнер
});

// Маршрути як зазвичай
Flight::route('/hello/@id', [ 'Greeting', 'hello' ]);
// або
Flight::route('/hello/@id', 'Greeting->hello');
// або
Flight::route('/hello/@id', 'Greeting::hello');

Flight::start();
```

## Методи маршрутизації

За замовчуванням, шаблони маршрутів відповідають усім методам запитів. Ви можете відповідати на конкретні методи, розміщуючи ідентифікатор перед URL.

```php
Flight::route('GET /', function () {
  echo 'I received a GET request.';  // Вивід повідомлення про отримання GET запиту
});

Flight::route('POST /', function () {
  echo 'I received a POST request.';  // Вивід повідомлення про отримання POST запиту
});

// Ви не можете використовувати Flight::get() для маршрутів, оскільки це метод для отримання змінних, а не створення маршруту.
// Flight::post('/', function() { /* код */ });
// Flight::patch('/', function() { /* код */ });
// Flight::put('/', function() { /* код */ });
// Flight::delete('/', function() { /* код */ });
```

Ви також можете призначити кілька методів одному зворотному виклику, використовуючи роздільник `|`:

```php
Flight::route('GET|POST /', function () {
  echo 'I received either a GET or a POST request.';  // Вивід повідомлення про отримання GET або POST запиту
});
```

Крім того, ви можете отримати об'єкт Router, який має деякі допоміжні методи для використання:

```php
$router = Flight::router();  // Отримання об'єкта маршрутизатора

// Призначення для всіх методів
$router->map('/', function() {
	echo 'hello world!';  // Вивід привітання
});

// GET запит
$router->get('/users', function() {
	echo 'users';  // Вивід списку користувачів
});
// $router->post();
// $router->put();
// $router->delete();
// $router->patch();
```

## Регулярні вирази

Ви можете використовувати регулярні вирази у своїх маршрутах:

```php
Flight::route('/user/[0-9]+', function () {
  // Це відповідатиме /user/1234
});
```

Хоча цей метод доступний, рекомендується використовувати іменовані параметри або іменовані параметри з регулярними виразами, оскільки вони більш читабельні і легші в обслуговуванні.

## Іменовані параметри

Ви можете вказати іменовані параметри у своїх маршрутах, які будуть передані зворотному виклику функції. **Це більше для читабельності маршруту, ніж для чогось іншого. Будь ласка, дивіться розділ нижче про важливу застереження.**

```php
Flight::route('/@name/@id', function (string $name, string $id) {
  echo "hello, $name ($id)!";  // Вивід привітання з ім'ям і ідентифікатором
});
```

Ви також можете включити регулярні вирази з вашими іменованими параметрами, використовуючи роздільник `:`:

```php
Flight::route('/@name/@id:[0-9]{3}', function (string $name, string $id) {
  // Це відповідатиме /bob/123
  // Але не відповідатиме /bob/12345
});
```

> **Примітка:** Підтримка груп регулярних виразів `()` з позиційними параметрами не підтримується. :'\(

### Важлива застереження

Хоча в прикладі вище здається, що `@name` безпосередньо пов'язаний із змінною `$name`, це не так. Порядок параметрів у зворотному виклику функції визначає, що буде передано йому. Отже, якщо ви поміняєте порядок параметрів у зворотному виклику функції, змінні також поміняються. Ось приклад:

```php
Flight::route('/@name/@id', function (string $id, string $name) {
  echo "hello, $name ($id)!";  // Вивід привітання з ідентифікатором і ім'ям, але в зворотному порядку
});
```

І якщо ви перейдете за наступним URL: `/bob/123`, виведення буде `hello, 123 (bob)!`. Будь ласка, будьте обережні при налаштуванні своїх маршрутів і зворотних викликів функцій.

## Опціональні параметри

Ви можете вказати іменовані параметри, які є опціональними для відповідності, обгорнувши сегменти в дужки.

```php
Flight::route(
  '/blog(/@year(/@month(/@day)))',
  function(?string $year, ?string $month, ?string $day) {
    // Це відповідатиме наступним URL:
    // /blog/2012/12/10
    // /blog/2012/12
    // /blog/2012
    // /blog
  }
);
```

Будь-які опціональні параметри, які не відповідають, будуть передані як `NULL`.

## Шаблони

Відповідність виконується лише для окремих сегментів URL. Якщо ви хочете відповідати кільком сегментам, ви можете використовувати шаблон `*`.

```php
Flight::route('/blog/*', function () {
  // Це відповідатиме /blog/2000/02/01
});
```

Щоб маршрутизувати всі запити до одного зворотного виклику, ви можете зробити:

```php
Flight::route('*', function () {
  // Виконати щось
});
```

## Передача

Ви можете передати виконання до наступного відповідного маршруту, повернувши `true` зі свого зворотного виклику функції.

```php
Flight::route('/user/@name', function (string $name) {
  // Перевірити якусь умову
  if ($name !== "Bob") {
    // Продовжити до наступного маршруту
    return true;  // Повернення true для передачі
  }
});

Flight::route('/user/*', function () {
  // Це буде викликано
});
```

## Псевдоніми маршрутів

Ви можете призначити псевдонім маршруту, щоб URL можна було динамічно генерувати пізніше у вашому коді (наприклад, у шаблоні).

```php
Flight::route('/users/@id', function($id) { echo 'user:'.$id; }, false, 'user_view');  // Визначення маршруту з псевдонімом

// Пізніше в коді десь
Flight::getUrl('user_view', [ 'id' => 5 ]);  // Поверне '/users/5'
```

Це особливо корисно, якщо ваш URL зміниться. У прикладі вище, припустимо, що користувачі були перенесені до `/admin/users/@id`.
З псевдонімами на місці, вам не потрібно змінювати будь-де посилання на псевдонім, оскільки псевдонім тепер поверне `/admin/users/5`, як у прикладі вище.

Псевдоніми маршрутів також працюють у групах:

```php
Flight::group('/users', function() {
    Flight::route('/@id', function($id) { echo 'user:'.$id; }, false, 'user_view');  // Визначення маршруту в групі
});


// Пізніше в коді десь
Flight::getUrl('user_view', [ 'id' => 5 ]);  // Поверне '/users/5'
```

## Інформація про маршрут

Якщо ви хочете перевірити інформацію про відповідний маршрут, ви можете запросити об'єкт маршруту, переданий вашому зворотному виклику, передавши `true` як третій параметр у методі маршруту. Об'єкт маршруту завжди буде останнім параметром, переданим вашій зворотній функції виклику.

```php
Flight::route('/', function(\flight\net\Route $route) {
  // Масив HTTP-методів, які відповідають
  $route->methods;  // Властивість для методів

  // Масив іменованих параметрів
  $route->params;  // Властивість для параметрів

  // Відповідний регулярний вираз
  $route->regex;  // Властивість для регулярного виразу

  // Містить вміст будь-якого '*' використаного в шаблоні URL
  $route->splat;  // Властивість для шаблонів

  // Показує шлях URL....якщо вам це дійсно потрібно
  $route->pattern;  // Властивість для шаблону

  // Показує, яке проміжне програмне забезпечення призначено цьому
  $route->middleware;  // Властивість для проміжного програмного забезпечення

  // Показує псевдонім, призначений цьому маршруту
  $route->alias;  // Властивість для псевдоніма
}, true);
```

## Групування маршрутів

Можливо, будуть випадки, коли ви захочете згрупувати пов'язані маршрути разом (наприклад, `/api/v1`).
Ви можете зробити це, використовуючи метод `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/users', function () {
	// Відповідає /api/v1/users
  });

  Flight::route('/posts', function () {
	// Відповідає /api/v1/posts
  });
});
```

Ви навіть можете вкладати групи в групи:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
	// Flight::get() отримує змінні, це не встановлює маршрут! Дивіться контекст об'єкта нижче
	Flight::route('GET /users', function () {
	  // Відповідає GET /api/v1/users
	});

	Flight::post('/posts', function () {
	  // Відповідає POST /api/v1/posts
	});

	Flight::put('/posts/1', function () {
	  // Відповідає PUT /api/v1/posts
	});
  });
  Flight::group('/v2', function () {

	// Flight::get() отримує змінні, це не встановлює маршрут! Дивіться контекст об'єкта нижче
	Flight::route('GET /users', function () {
	  // Відповідає GET /api/v2/users
	});
  });
});
```

### Групування з контекстом об'єкта

Ви все ще можете використовувати групування маршрутів з об'єктом `Engine` таким чином:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {

  // Використовуйте змінну $router
  $router->get('/users', function () {
	// Відповідає GET /api/v1/users
  });

  $router->post('/posts', function () {
	// Відповідає POST /api/v1/posts
  });
});
```

### Групування з проміжним програмним забезпеченням

Ви також можете призначити проміжне програмне забезпечення групі маршрутів:

```php
Flight::group('/api/v1', function () {
  Flight::route('/users', function () {
	// Відповідає /api/v1/users
  });
}, [ MyAuthMiddleware::class ]);  // або [ new MyAuthMiddleware() ], якщо ви хочете використовувати екземпляр
```

Дивіться більше деталей на сторінці [group middleware](/learn/middleware#grouping-middleware).

## Маршрутизація ресурсів

Ви можете створити набір маршрутів для ресурсу, використовуючи метод `resource`. Це створить набір маршрутів для ресурсу, який відповідає RESTful-конвенціям.

Щоб створити ресурс, зробіть наступне:

```php
Flight::resource('/users', UsersController::class);  // Створення ресурсу
```

І що станеться у фоновому режимі, це створить наступні маршрути:

```php
[
      'index' => 'GET ',
      'create' => 'GET /create',
      'store' => 'POST ',
      'show' => 'GET /@id',
      'edit' => 'GET /@id/edit',
      'update' => 'PUT /@id',
      'destroy' => 'DELETE /@id'
]
```

І ваш контролер буде виглядати так:

```php
class UsersController
{
    public function index(): void
    {
    }

    public function show(string $id): void
    {
    }

    public function create(): void
    {
    }

    public function store(): void
    {
    }

    public function edit(string $id): void
    {
    }

    public function update(string $id): void
    {
    }

    public function destroy(string $id): void
    {
    }
}
```

> **Примітка**: Ви можете переглянути newly додані маршрути з `runway`, запустивши `php runway routes`.

### Налаштування маршрутів ресурсів

Є кілька опцій для налаштування маршрутів ресурсів.

#### Базовий псевдонім

Ви можете налаштувати `aliasBase`. За замовчуванням псевдонім - це остання частина вказаного URL.
Наприклад, `/users/` призведе до `aliasBase` як `users`. Коли ці маршрути створюються, псевдоніми - `users.index`, `users.create` тощо. Якщо ви хочете змінити псевдонім, встановіть `aliasBase` на значення, яке ви хочете.

```php
Flight::resource('/users', UsersController::class, [ 'aliasBase' => 'user' ]);  // Налаштування базового псевдоніма
```

#### Тільки і крім

Ви також можете вказати, які маршрути ви хочете створити, використовуючи опції `only` і `except`.

```php
Flight::resource('/users', UsersController::class, [ 'only' => [ 'index', 'show' ] ]);  // Тільки вказані маршрути
```

```php
Flight::resource('/users', UsersController::class, [ 'except' => [ 'create', 'store', 'edit', 'update', 'destroy' ] ]);  // Крім вказаних маршрутів
```

Це базові опції білого і чорного списків, щоб ви могли вказати, які маршрути ви хочете створити.

#### Проміжне програмне забезпечення

Ви також можете вказати проміжне програмне забезпечення для виконання на кожному з маршрутів, створених методом `resource`.

```php
Flight::resource('/users', UsersController::class, [ 'middleware' => [ MyAuthMiddleware::class ] ]);  // Додавання проміжного програмного забезпечення
```

## Стримінг

Тепер ви можете стрімити відповіді клієнту, використовуючи метод `streamWithHeaders()`.
Це корисно для надсилання великих файлів, тривалих процесів або генерації великих відповідей.
Стримінг маршруту обробляється трохи інакше, ніж звичайний маршрут.

> **Примітка:** Стримінг відповідей доступний лише якщо у вас [`flight.v2.output_buffering`](/learn/migrating-to-v3#output_buffering) встановлено як false.

### Стримінг з ручними заголовками

Ви можете стрімити відповідь клієнту, використовуючи метод `stream()` на маршруті. Якщо ви зробите це, ви повинні встановити всі заголовки вручну перед тим, як вивести що-небудь клієнту.
Це робиться за допомогою функції `header()` php або методу `Flight::response()->setRealHeader()`.

```php
Flight::route('/@filename', function($filename) {

	// очевидно, ви б очистили шлях і таке інше.
	$fileNameSafe = basename($filename);  // Отримання безпечного імені файлу

	// Якщо у вас є додаткові заголовки для встановлення тут після виконання маршруту
	// ви повинні визначити їх перед тим, як щось буде виведено.
	// Вони повинні бути сирим викликом функції header() або викликом Flight::response()->setRealHeader()
	header('Content-Disposition: attachment; filename="'.$fileNameSafe.'"');  // Встановлення заголовка для завантаження
	// або
	Flight::response()->setRealHeader('Content-Disposition', 'attachment; filename="'.$fileNameSafe.'"');

	$fileData = file_get_contents('/some/path/to/files/'.$fileNameSafe);  // Читання вмісту файлу

	// Перевірка помилок і таке інше
	if(empty($fileData)) {
		Flight::halt(404, 'File not found');  // Зупинка з помилкою, якщо файл не знайдено
	}

	// Встановлення довжини вмісту вручну, якщо ви хочете
	header('Content-Length: '.filesize($filename));  // Встановлення заголовка довжини

	// Стримінг даних клієнту
	echo $fileData;

// Це магічна лінія тут
})->stream();  // Активувати стримінг
```

### Стримінг з заголовками

Ви також можете використовувати метод `streamWithHeaders()` для встановлення заголовків перед початком стримінгу.

```php
Flight::route('/stream-users', function() {

	// ви можете додати будь-які додаткові заголовки, які ви хочете тут
	// ви просто повинні використовувати header() або Flight::response()->setRealHeader()

	// однак ви витягуєте свої дані, просто як приклад...
	$users_stmt = Flight::db()->query("SELECT id, first_name, last_name FROM users");  // Запит до бази даних

	echo '{';  // Початок JSON
	$user_count = count($users);  // Підрахунок користувачів
	while($user = $users_stmt->fetch(PDO::FETCH_ASSOC)) {
		echo json_encode($user);  // Кодування користувача в JSON
		if(--$user_count > 0) {
			echo ',';  // Додавання коми, якщо не останній
		}

		// Це вимагається для надсилання даних клієнту
		ob_flush();  // Вивід буфера
	}
	echo '}';  // Кінець JSON

// Це спосіб встановлення заголовків перед початком стримінгу.
})->streamWithHeaders([
	'Content-Type' => 'application/json',  // Встановлення типу вмісту
	'Content-Disposition' => 'attachment; filename="users.json"',  // Встановлення заголовка для завантаження
	// необов'язковий код статусу, за замовчуванням 200
	'status' => 200
]);
```