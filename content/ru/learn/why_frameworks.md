# Зачем фреймворк?

Некоторые программисты категорически против использования фреймворков. Они утверждают, что фреймворки надуты, медленны и сложны в изучении. Они говорят, что фреймворки излишни и что вы можете писать лучший код без них. Определенно можно высказать некоторые справедливые замечания о недостатках использования фреймворков. Однако есть и множество преимуществ использования фреймворков.

## Причины использования фреймворка

Вот несколько причин, почему вам может захотеться рассмотреть использование фреймворка:

- **Быстрая разработка**: Фреймворки предоставляют множество функциональности из коробки. Это означает, что вы можете быстрее создавать веб-приложения. Вам не нужно писать столько кода, потому что фреймворк предоставляет множество функциональности, которые вам нужны.
- **Согласованность**: Фреймворки предоставляют последовательный способ сделать вещи. Это облегчает понимание того, как работает код, и упрощает другим разработчикам понимание вашего кода. Если вы пишете по скрипту, вы можете потерять согласованность между скриптами, особенно если работаете с группой разработчиков.
- **Безопасность**: Фреймворки предоставляют средства безопасности, которые помогают защитить ваши веб-приложения от распространенных угроз безопасности. Это означает, что вам не нужно так сильно беспокоиться о безопасности, потому что фреймворк заботится об этом за вас.
- **Сообщество**: У фреймворков есть большие сообщества разработчиков, которые вносят свой вклад в развитие фреймворка. Это означает, что вы можете получить помощь от других разработчиков, если у вас возникнут вопросы или проблемы. Это также означает, что доступно множество ресурсов для помощи в изучении использования фреймворка.
- **Лучшие практики**: Фреймворки созданы с использованием лучших практик. Это означает, что вы можете учиться на примере фреймворка и использовать те же лучшие практики в своем собственном коде. Это может помочь вам стать лучшим программистом. Иногда вы не знаете, чего не знаете, и это может вам сыграть на руку в конечном итоге.
- **Расширяемость**: Фреймворки разработаны для расширения. Это означает, что вы можете добавлять свою собственную функциональность в фреймворк. Это позволяет создавать веб-приложения, которые подходят под ваши конкретные потребности.

Flight – это микро-фреймворк. Это означает, что он мал и легковесен. Он не обеспечивает столько функциональности, сколько большие фреймворки, такие как Laravel или Symfony. Однако он предоставляет множество функциональности, необходимых для создания веб-приложений. Он также легок в изучении и использовании. Это делает его хорошим выбором для быстрого и простого создания веб-приложений. Если вы новичок в фреймворках, Flight – отличный фреймворк для начала. Он поможет вам узнать о преимуществах использования фреймворков, не перегружая вас излишней сложностью. После того как у вас накопится опыт работы с Flight, будет легче переходить на более сложные фреймворки, такие как Laravel или Symfony, однако Flight все еще может помочь создать успешное и надежное приложение.

## Что такое маршрутизация?

Маршрутизация является ядром фреймворка Flight, но что это такое точно? Маршрутизация – это процесс принятия URL и сопоставления его с определенной функцией в вашем коде. Именно так вы можете заставить ваш веб-сайт выполнять разные действия в зависимости от запрошенного URL. Например, вы можете хотеть показать профиль пользователя при посещении `/user/1234`, но показать список всех пользователей при посещении `/users`. Все это делается через маршрутизацию.

Это может работать примерно так:

- Пользователь заходит в ваш браузер и вводит `http://example.com/user/1234`.
- Сервер получает запрос, смотрит на URL и передает его в ваш код приложения Flight.
- Допустим, у вас в коде Flight есть что-то вроде `Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);`. Ваш код приложения Flight смотрит на URL, видит, что он соответствует определенному маршруту, и затем выполняет код, который вы определили для этого маршрута.
- Маршрутизатор Flight затем вызывает метод `viewUserProfile($id)` в классе `UserController`, передавая `1234` в качестве аргумента `$id` в метод.
- Код в вашем методе `viewUserProfile()` затем выполняет то, что вы ему сказали. Вы можете, например, выведете некоторый HTML для страницы профиля пользователя или, если это RESTful API, можете вывести JSON-ответ с информацией о пользователе.
- Flight завершает это красивой ленточкой, генерирует заголовки ответа и отправляет их обратно в браузер пользователя.
- Пользователь испытывает радость и дарит себе теплый объятие!

### Зачем это важно?

Наличие правильного централизованного маршрутизатора может действительно упростить вашу жизнь! Просто может быть сложно это увидеть сразу. Вот несколько причин, почему:

- **Централизованная маршрутизация**: Вы можете хранить все ваши маршруты в одном месте. Это упрощает просмотр доступных маршрутов и их действий. Это также упрощает изменение их, если это необходимо.
- **Параметры маршрута**: Вы можете использовать параметры маршрута для передачи данных в ваши методы маршрутов. Это отличный способ сохранить ваш код аккуратным и организованным.
- **Группировка маршрутов**: Вы можете объединять маршруты в группы. Это отлично для организации вашего кода и для применения [промежуточного ПО](middleware) к группе маршрутов.
- **Псевдонимы маршрутов**: Вы можете присвоить псевдоним маршруту, так что URL может динамически формироваться позже в вашем коде (например, в шаблоне). Например, вместо хардкода `/user/1234` в вашем коде, вы можете ссылаться на псевдоним `user_view` и передавать `id` в качестве параметра. Это прекрасно, если вы решите позже изменить его на `/admin/user/1234`. Вам не придется изменять все жестко закодированные URL, просто URL, привязанный к маршруту.
- **Промежуточное ПО маршрута**: Вы можете добавлять промежуточное ПО к вашим маршрутам. Промежуточное ПО невероятно удобно для добавления определенных поведений в ваше приложение, таких как аутентификация того, что определенный пользователь может получить доступ к маршруту или группе маршрутов.

Наверняка вы знакомы с способом создания сайта по скрипту. У вас может быть файл `index.php`, в котором много операторов `if` для проверки URL и выполнения конкретной функции на основе URL. Это форма маршрутизации, но она не очень организована и может быстро выйти из-под контроля. Маршрутизационная система Flight представляет собой более организованный и мощный способ обработки маршрутов.

Так?

```php

// /user/view_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	viewUserProfile($id);
}

// /user/edit_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	editUserProfile($id);
}

// итд...
```

Или так?

```php

// index.php
Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);
Flight::route('/user/@id/edit', [ 'UserController', 'editUserProfile' ]);

// Возможно, в вашем app/controllers/UserController.php
class UserController {
	public function viewUserProfile($id) {
		// делать что-то
	}

	public function editUserProfile($id) {
		// делать что-то
	}
}
```

Надеюсь, теперь вы начинаете видеть преимущества использования централизованной системы маршрутизации. Это намного проще управлять и понимать в долгосрочной перспективе!

## Запросы и ответы

Flight предоставляет простой и удобный способ обработки запросов и ответов. Это ядро работы веб-фреймворка. Он получает запрос от браузера пользователя, обрабатывает его, а затем отправляет обратно ответ. Таким образом вы можете создавать веб-приложения, которые делают такие вещи, как показ профиля пользователя, вход пользователя или размещение новой статьи в блоге пользователя.

### Запросы

Запрос – это то, что отправляет браузер пользователя на ваш сервер при посещении вашего веб-сайта. Этот запрос содержит информацию о том, что хочет сделать пользователь. Например, он может содержать информацию о том, какой URL пользователь хочет посетить, какие данные пользователь хочет отправить на ваш сервер или какие данные пользователь хочет получить от вашего сервера. Важно понимать, что запрос доступен только для чтения. Вы не можете изменить запрос, но можете прочитать из него.

Flight предоставляет простой способ получить информацию о запросе. Вы можете получить информацию о запросе, используя метод `Flight::request()`. Этот метод возвращает объект `Request`, который содержит информацию о запросе. Вы можете использовать этот объект для доступа к информации о запросе, такой как URL, метод или данные, которые пользователь отправил на ваш сервер.

### Ответы

Ответ – это то, что ваш сервер отправляет обратно на браузер пользователя при посещении вашего веб-сайта. Этот ответ содержит информацию о том, что ваш сервер хочет сделать. Например, он может содержать информацию о том, какие данные ваш сервер хочет отправить пользователю, какие данные ваш сервер хочет получить от пользователя или какие данные ваш сервер хочет сохранить на компьютере пользователя.

Flight предоставляет простой способ отправить ответ на браузер пользователя. Вы можете отправить ответ, используя метод `Flight::response()`. Этот метод принимает объект `Response` в качестве аргумента и отправляет ответ на браузер пользователя. Вы можете использовать этот объект для отправки ответа на браузер пользователя, такого как HTML, JSON или файл. Flight помогает вам автоматически генерировать некоторые части ответа, чтоб упростить вещи, но в конечном итоге у вас есть контроль над тем, что вы отправляете пользователю.