# Навчання

Ця сторінка є посібником для вивчення Flight. Вона охоплює основи фреймворку та те, як його використовувати.

## <a name="routing"></a> Маршрутизація

Маршрутизація у Flight здійснюється шляхом порівняння шаблону URL з функцією зворотного виклику.

``` php
Flight::route('/', function(){
    echo 'привіт, світ!';
});
```

Функція зворотного виклику може бути будь-яким об'єктом, який можна викликати. Тож ви можете використовувати звичайну функцію:

``` php
function hello(){
    echo 'привіт, світ!';
}

Flight::route('/', 'hello');
```

Або метод класу:

``` php
class Greeting {
    public static function hello() {
        echo 'привіт, світ!';
    }
}

Flight::route('/', array('Greeting','hello'));
```

Або метод об'єкта:

``` php
class Greeting
{
    public function __construct() {
        $this->name = 'Джон Доу';
    }

    public function hello() {
        echo "Привіт, {$this->name}!";
    }
}

$greeting = new Greeting();

Flight::route('/', array($greeting, 'hello'));
```

Маршрути зіставляються в порядку їх визначення. Перший маршрут, що відповідає запиту, буде викликано.

### Метод маршрутизації

За замовчуванням шаблони маршрутів порівнюються з усіма методами запиту. Ви можете відповідати на конкретні методи, поставивши ідентифікатор перед URL.

``` php
Flight::route('GET /', function(){
    echo 'Я отримав GET-запит.';
});

Flight::route('POST /', function(){
    echo 'Я отримав POST-запит.';
});
```

Ви також можете відобразити кілька методів на один зворотний виклик, використовуючи роздільник `|`:

``` php
Flight::route('GET|POST /', function(){
    echo 'Я отримав або GET, або POST запит.';
});
```

### Регулярні вирази

Ви можете використовувати регулярні вирази у своїх маршрутах:

``` php
Flight::route('/user/[0-9]+', function(){
    // Це буде відповідати /user/1234
});
```

### Іменовані параметри

Ви можете вказати іменовані параметри у ваших маршрутах, які будуть передані до функції зворотного виклику.

``` php
Flight::route('/@name/@id', function($name, $id){
    echo "привіт, $name ($id)!";
});
```

Ви також можете включити регулярні вирази разом з вашими іменованими параметрами, використовуючи роздільник `:`:

``` php
Flight::route('/@name/@id:[0-9]{3}', function($name, $id){
    // Це буде відповідати /bob/123
    // Але не відповість на /bob/12345
});
```

### Необов'язкові параметри

Ви можете вказати іменовані параметри, які є необов'язковими для зіставлення, обгортаючи сегменти в дужки.

``` php
Flight::route('/blog(/@year(/@month(/@day)))', function($year, $month, $day){
    // Це буде відповідати таким URL:
    // /blog/2012/12/10
    // /blog/2012/12
    // /blog/2012
    // /blog
});
```

Будь-які необов'язкові параметри, які не відповідали, будуть передані як NULL.

### Символи підстановки

Зіставлення проводиться лише для окремих сегментів URL. Якщо ви хочете зробити відповідність кількома сегментами, можете використовувати символ підстановки `*`.

``` php
Flight::route('/blog/*', function(){
    // Це буде відповідати /blog/2000/02/01
});
```

Щоб направити всі запити до одного зворотного виклику, ви можете зробити так:

``` php
Flight::route('*', function(){
    // Зробіть щось
});
```

### Передача

Ви можете передати виконання наступному відповідному маршруту, повернувши `true` з функції зворотного виклику.

``` php
Flight::route('/user/@name', function($name){
    // Перевірте деяку умову
    if ($name != "Боб") {
        // Продовжити до наступного маршруту
        return true;
    }
});

Flight::route('/user/*', function(){
    // Це буде викликано
});
```

### Інформація про маршрут

Якщо ви хочете переглянути інформацію про відповідний маршрут, ви можете запросити об'єкт маршруту, щоб його передали вашій функції зворотного виклику, передавши `true` як третій параметр у методі маршруту. Об'єкт маршруту завжди буде останнім параметром, переданим вашій функції зворотного виклику.

``` php
Flight::route('/', function($route){
    // Масив методів HTTP, з якими відповідали
    $route->methods;

    // Масив іменованих параметрів
    $route->params;

    // Відповідний регулярний вираз
    $route->regex;

    // Містить вміст будь-якого '*' викоростного у шаблоні URL
    $route->splat;
}, true);
```
### Групування маршрутів

Іноді вам може знадобитися об'єднати пов'язані маршрути разом (наприклад, `/api/v1`).
Ви можете це зробити, використовуючи метод `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/users', function () {
	// Відповідає /api/v1/users
  });

  Flight::route('/posts', function () {
	// Відповідає /api/v1/posts
  });
});
```

Ви також можете навіть вкладати групи груп:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
	// Flight::get() отримує змінні, він не задає маршрут! Дивіться об'єкт контексту нижче
	Flight::route('GET /users', function () {
	  // Відповідає GET /api/v1/users
	});

	Flight::post('/posts', function () {
	  // Відповідає POST /api/v1/posts
	});

	Flight::put('/posts/1', function () {
	  // Відповідає PUT /api/v1/posts
	});
  });
  Flight::group('/v2', function () {

	// Flight::get() отримує змінні, він не задає маршрут! Дивіться об'єкт контексту нижче
	Flight::route('GET /users', function () {
	  // Відповідає GET /api/v2/users
	});
  });
});
```

#### Групування з контекстом об'єкта

Ви все ще можете використовувати групування маршрутів з об'єктом `Engine` наступним чином:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {
  $router->get('/users', function () {
	// Відповідає GET /api/v1/users
  });

  $router->post('/posts', function () {
	// Відповідає POST /api/v1/posts
  });
});
```

### Псевдоніми маршруту

Ви можете призначити псевдонім маршруту, щоб URL можна було динамічно згенерувати пізніше у вашому коді (наприклад, як шаблон).

```php
Flight::route('/users/@id', function($id) { echo 'користувач:'.$id; }, false, 'user_view');

// пізніше в коді десь
Flight::getUrl('user_view', [ 'id' => 5 ]); // поверне '/users/5'
```

Це особливо корисно, якщо ваш URL раптово зміниться. У наведеному вище прикладі, припустимо, що користувачів перенесли до `/admin/users/@id`.
З використанням псевдонімів, вам не потрібно змінювати будь-де, де ви посилаєтесь на псевдонім, адже псевдонім тепер поверне `/admin/users/5`, як у наведеному вище прикладі.

Псевдоніми маршруту також працюють у групах:

```php
Flight::group('/users', function() {
    Flight::route('/@id', function($id) { echo 'користувач:'.$id; }, false, 'user_view');
});


// пізніше в коді десь
Flight::getUrl('user_view', [ 'id' => 5 ]); // поверне '/users/5'
```

## <a name="extending"></a> Розширення

Flight розроблений як розширювальний фреймворк. Фреймворк постачається з набором
за замовчуванням методів і компонентів, але дозволяє вам відображати свої власні методи,
реєструвати свої власні класи або навіть переопреділяти існуючі класи та методи.

### Відображення методів

Щоб відобразити свій власний користувацький метод, ви використовуєте функцію `map`:

``` php
// Відобразіть свій метод
Flight::map('hello', function($name){
    echo "привіт $name!";
});

// Викличте свій користувацький метод
Flight::hello('Боб');
```

### Реєстрація класів

Щоб зареєструвати свій клас, ви використовуєте функцію `register`:

``` php
// Зареєструйте свій клас
Flight::register('user', 'User');

// Отримайте екземпляр свого класу
$user = Flight::user();
```

Метод реєстрації також дозволяє вам передавати параметри до конструктора вашого класу. Таким чином, коли ви завантажите свій користувацький клас, він буде попередньо ініціалізований.
Ви можете визначити параметри конструктора, передавши додатковий масив.
Ось приклад завантаження з'єднання з базою даних:

``` php
// Зареєструйте клас з параметрами конструктора
Flight::register('db', 'PDO', array('mysql:host=localhost;dbname=test','user','pass'));

// Отримайте екземпляр свого класу
// Це створить об'єкт з визначеними параметрами
//
//     new PDO('mysql:host=localhost;dbname=test','user','pass');
//
$db = Flight::db();
```

Якщо ви передасте додатковий параметр зворотного виклику, він буде виконано негайно після створення класу. Це дозволяє виконати будь-які процедури налаштування для вашого
нового об'єкта. Функція зворотного виклику приймає один параметр, екземпляр нового об'єкта.

``` php
// Функція зворотного виклику отримає об'єкт, який було створено
Flight::register('db', 'PDO', array('mysql:host=localhost;dbname=test','user','pass'),
  function($db){
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  }
);
```

За замовчуванням, щоразу, коли ви завантажуєте свій клас, ви отримаєте спільний екземпляр.
Щоб отримати новий екземпляр класу, просто передайте `false` як параметр:

``` php
// Спільний екземпляр класу
$shared = Flight::db();

// Новий екземпляр класу
$new = Flight::db(false);
```

Пам'ятайте, що відображені методи мають перевагу над зареєстрованими класами. Якщо ви
оголосите обидва, використовуючи одне й те саме ім'я, буде викликано лише відображений метод.

## <a name="overriding"></a> Переоприділення

Flight дозволяє вам переоприділяти його стандартну функціональність, щоб задовольнити ваші потреби,
не модифікуючи жодного коду.

Наприклад, коли Flight не може зіставити URL маршруту, він викликає метод `notFound`,
який надсилає універсальну відповідь `HTTP 404`. Ви можете переоприділити цю поведінку,
використовуючи метод `map`:

``` php
Flight::map('notFound', function(){
    // Відобразити користувацьку 404 сторінку
    include 'errors/404.html';
});
```

Flight також дозволяє вам замінювати основні компоненти фреймворку.
Наприклад, ви можете замінити стандартний клас Router вашим власним користувацьким класом:

``` php
// Зареєструйте свій користувацький клас
Flight::register('router', 'MyRouter');

// Коли Flight завантажить екземпляр Router, він завантажить ваш клас
$myrouter = Flight::router();
```

Методи фреймворку, такі як `map` і `register`, проте не можуть бути переоприділені. Ви
отримаєте помилку, якщо спробуєте це зробити.

## <a name="filtering"></a> Фільтрація

Flight дозволяє вам фільтрувати методи до і після їх виклику. Немає
попередньо визначених хуків, які потрібно запам'ятати. Ви можете фільтрувати будь-які стандартні методи фреймворку, а також будь-які користувацькі методи, які ви зареєстрували.

Функція фільтра виглядає так:

``` php
function(&$params, &$output) {
    // Код фільтра
}
```

Використовуючи передані змінні, ви можете маніпулювати вхідними параметрами та/або виходом.

Ви можете запустити фільтр перед методом, зробивши:

``` php
Flight::before('start', function(&$params, &$output){
    // Зробіть щось
});
```

Ви можете запустити фільтр після методу, зробивши:

``` php
Flight::after('start', function(&$params, &$output){
    // Зробіть щось
});
```

Ви можете додати стільки фільтрів, скільки хочете, до будь-якого методу. Вони будуть викликатися в
порядку їх декларації.

Ось приклад процесу фільтрації:

``` php
// Відобразіть користувацький метод
Flight::map('hello', function($name){
    return "Привіт, $name!";
});

// Додайте фільтр перед
Flight::before('hello', function(&$params, &$output){
    // Маніпулюйте параметром
    $params[0] = 'Фред';
});

// Додайте фільтр після
Flight::after('hello', function(&$params, &$output){
    // Маніпулюйте виходом
    $output .= " Гарного дня!";
});

// Викличте користувацький метод
echo Flight::hello('Боб');
```

Це повинно відобразити:

``` html
Привіт Фред! Гарного дня!
```

Якщо ви визначили кілька фільтрів, ви можете перервати ланцюг, повернувши `false`
в будь-якій з ваших функцій фільтра:

``` php
Flight::before('start', function(&$params, &$output){
    echo 'один';
});

Flight::before('start', function(&$params, &$output){
    echo 'два';

    // Це зупинить ланцюг
    return false;
});

// Це не буде викликано
Flight::before('start', function(&$params, &$output){
    echo 'три';
});
```

Зверніть увагу, основні методи, такі як `map` і `register`, не можуть бути відфільтровані, оскільки вони
викликаються безпосередньо, а не викликані динамічно.

## <a name="variables"></a> Змінні

Flight дозволяє вам зберігати змінні, щоб їх можна було використовувати в будь-якому місці вашого застосунку.

``` php
// Збережіть свою змінну
Flight::set('id', 123);

// В іншому місці вашого застосунку
$id = Flight::get('id');
```
Щоб перевірити, чи була змінна налаштована, ви можете зробити:

``` php
if (Flight::has('id')) {
     // Зробити щось
}
```

Ви можете очистити змінну, зробивши:

``` php
// Очищає змінну id
Flight::clear('id');

// Очищає всі змінні
Flight::clear();
```

Flight також використовує змінні для цілей конфігурації.

``` php
Flight::set('flight.log_errors', true);
```

## <a name="views"></a> Види

Flight надає деякі основні функції шаблонізації за замовчуванням. Щоб відобразити шаблон
вигляду, викличте метод `render` з назвою файлу шаблону та необов'язковими
даними шаблону:

``` php
Flight::render('hello.php', array('name' => 'Боб'));
```

Дані шаблону, які ви передаєте, автоматично інжектуються в шаблон і можуть
бути посиланнями як локальна змінна. Файли шаблонів — це просто файли PHP. Якщо
вміст шаблонного файлу `hello.php` такий:

``` php
Привіт, '<?php echo $name; ?>'!
```

Вихід буде:

``` html
Привіт, Боб!
```

Ви також можете вручну встановлювати змінні вигляду, використовуючи метод set:

``` php
Flight::view()->set('name', 'Боб');
```

Змінна `name` тепер доступна у всіх ваших видах. Ви можете просто зробити:

``` php
Flight::render('hello');
```

Зверніть увагу, що, вказуючи назву шаблону в методі render, ви можете
опустити розширення `.php`.

За замовчуванням Flight буде шукати каталог `views` для шаблонних файлів. Ви можете
встановити альтернативний шлях для ваших шаблонів, задавши таку конфігурацію:

``` php
Flight::set('flight.views.path', '/path/to/views');
```

### Макети

Звично, що веб-сайти мають один шаблон макета з мінливим
вмістом. Щоб відобразити вміст, який буде використано в макеті, ви можете передати необов'язковий
параметр до методу `render`.

``` php
Flight::render('header', array('heading' => 'Привіт'), 'header_content');
Flight::render('body', array('body' => 'Світ'), 'body_content');
```

Ваш вигляд буде тоді мати збережені змінні під назвами `header_content` та `body_content`.
Ви можете потім відобразити свій макет, зробивши так:

``` php
Flight::render('layout', array('title' => 'Головна сторінка'));
```

Якщо шаблонні файли виглядають ось так:

`header.php`:

``` php
<h1><?php echo $heading; ?></h1>
```

`body.php`:

``` php
<div><?php echo $body; ?></div>
```

`layout.php`:

``` php
<html>
<head>
<title><?php echo $title; ?></title>
</head>
<body>
<?php echo $header_content; ?>
<?php echo $body_content; ?>
</body>
</html>
```

Вихід буде:

``` html
<html>
<head>
<title>Головна сторінка</title>
</head>
<body>
<h1>Привіт</h1>
<div>Світ</div>
</body>
</html>
```

### Користувацькі види

Flight дозволяє вам замінювати стандартний двигун вигляду, просто зареєструвавши
ваш власний клас вигляду. Ось як ви б використали шаблонний двигун [Smarty](http://www.smarty.net/)
для ваших виглядів:

``` php
// Завантажте бібліотеку Smarty
require './Smarty/libs/Smarty.class.php';

// Зареєструйте Smarty як клас вигляду
// Також передайте функцію зворотного виклику для налаштування Smarty під час завантаження
Flight::register('view', 'Smarty', array(), function($smarty){
    $smarty->template_dir = './templates/';
    $smarty->compile_dir = './templates_c/';
    $smarty->config_dir = './config/';
    $smarty->cache_dir = './cache/';
});

// Призначити дані шаблону
Flight::view()->assign('name', 'Боб');

// Відобразити шаблон
Flight::view()->display('hello.tpl');
```

Для повноти, вам також слід переоприділити стандартний метод відображення Flight:

``` php
Flight::map('render', function($template, $data){
    Flight::view()->assign($data);
    Flight::view()->display($template);
});
```

## <a name="errorhandling"></a> Обробка помилок

### Помилки та виключення

Усі помилки та виключення перехоплюються Flight і передаються методу `error`.
Стандартна поведінка — надіслати універсальну відповідь `HTTP 500 Internal Server Error`
з деякою інформацією про помилку.

Ви можете переоприділити цю поведінку для своїх потреб:

``` php
Flight::map('error', function(Exception $ex){
    // Обробка помилки
    echo $ex->getTraceAsString();
});
```

За замовчуванням помилки не записуються до веб-сервера. Ви можете включити це, змінивши конфігурацію:

``` php
Flight::set('flight.log_errors', true);
```

### Не знайдено

Коли URL не може бути знайдено, Flight викликає метод `notFound`. Стандартна
поведінка — надіслати відповідь `HTTP 404 Not Found` з простим повідомленням.

Ви можете переоприділити цю поведінку для своїх потреб:

``` php
Flight::map('notFound', function(){
    // Обробка не знайдено
});
```

## <a name="redirects"></a> Перенаправлення

Ви можете перенаправити поточний запит, використовуючи метод `redirect` і передаючи
новий URL:

``` php
Flight::redirect('/new/location');
```

За замовчуванням Flight надсилає код статусу HTTP 303. Ви також можете вибірково
встановити користувацький код:

``` php
Flight::redirect('/new/location', 401);
```

## <a name="requests"></a> Запити

Flight інкапсулює HTTP запит у єдиному об'єкті, до якого можна
отримати доступ, роблячи:

``` php
$request = Flight::request();
```

Об'єкт запиту надає такі властивості:

``` html
url - URL, що запитується
base - батьківський підкаталог URL
method - метод запиту (GET, POST, PUT, DELETE)
referrer - URL посилання
ip - IP-адреса клієнта
ajax - Чи є запит AJAX запитом
scheme - серверний протокол (http, https)
user_agent - Інформація про браузер
type - тип вмісту
length - довжина вмісту
query - параметри рядка запиту
data - Дані Post або JSON дані
cookies - дані файлів cookie
files - завантажені файли
secure - Чи є з'єднання безпечним
accept - параметри HTTP прийняття
proxy_ip - IP-адреса проксі-клієнта
```

Ви можете отримати доступ до властивостей `query`, `data`, `cookies` та `files`
як масивів або об'єктів.

Отже, щоб отримати параметр рядка запиту, ви можете зробити:

``` php
$id = Flight::request()->query['id'];
```

Або ви можете зробити:

``` php
$id = Flight::request()->query->id;
```

### Сировинне тіло запиту

Щоб отримати сировинне тіло HTTP запиту, наприклад, при роботі з запитами PUT, ви можете зробити:

``` php
$body = Flight::request()->getBody();
```

### JSON Вхідні дані

Якщо ви надсилаєте запит з типом `application/json` і даними `{"id": 123}`, вони будуть доступні
з властивості `data`:

``` php
$id = Flight::request()->data->id;
```

## <a name="stopping"></a> Зупинка

Ви можете зупинити фреймворк у будь-який момент, викликавши метод `halt`:

``` php
Flight::halt();
```

Ви також можете вказати необов'язковий код статусу `HTTP` та повідомлення:

``` php
Flight::halt(200, 'Зараз повернемось...');
```

Виклик `halt` скасує будь-який вміст відповіді до цього моменту. Якщо ви хочете зупинити
фреймворк і вивести поточну відповідь, використовуйте метод `stop`:

``` php
Flight::stop();
```

## <a name="httpcaching"></a> HTTP кешування

Flight надає вбудовану підтримку кешування на рівні HTTP. Якщо умови кешування
виконуються, Flight поверне відповідь HTTP `304 Not Modified`. Наступного разу, коли клієнт запросить той самий ресурс, йому запропонують використовувати свою локальну
версію кешу.

### Останнє модифіковане

Ви можете використовувати метод `lastModified` та передати UNIX-мітку часу, щоб встановити дату
та час останнього модифікації сторінки. Клієнт продовжить використовувати кеш до
зміни значення останньої модифікації.

``` php
Flight::route('/news', function(){
    Flight::lastModified(1234567890);
    echo 'Цей вміст буде кешуватися.';
});
```

### ETag

Кешування `ETag` подібне до `Last-Modified`, з тією різницею, що ви можете вказати будь-який ідентифікатор для ресурсу:

``` php
Flight::route('/news', function(){
    Flight::etag('my-unique-id');
    echo 'Цей вміст буде кешуватися.';
});
```

Пам'ятайте, що виклик або `lastModified`, або `etag` встановлює та перевіряє
значення кешу. Якщо значення кешу залишилося без змін між запитами, Flight негайно
надішле відповідь `HTTP 304` і припинить обробку.

## <a name="json"></a> JSON

Flight надає підтримку для відправлення JSON і JSONP-відповідей. Щоб відправити JSON-відповідь, ви
передаєте деякі дані для кодування в JSON:

``` php
Flight::json(array('id' => 123));
```

Для запитів JSONP ви можете додатково передати назву параметра запиту, який ви
використовуєте для визначення функції зворотного виклику:

``` php
Flight::jsonp(array('id' => 123), 'q');
```

Отже, при виконанні GET-запиту з `?q=my_func`, ви повинні отримати вихід:

``` json
my_func({"id":123});
```

Якщо ви не передасте назву параметра запиту, за замовчуванням використовуватиметься `jsonp`.

## <a name="configuration"></a> Конфігурація

Ви можете налаштувати певні поведінки Flight, встановивши значення конфігурації
через метод `set`.

``` php
Flight::set('flight.log_errors', true);
```

Наведено нижче список усіх доступних налаштувань конфігурації:

``` html 
flight.base_url - Переоприділити базовий URL запиту. (за замовчуванням: null)
flight.case_sensitive - Регістр чутливого порівняння для URL. (за замовчуванням: false)
flight.handle_errors - Дозволити Flight обробляти всі помилки внутрішньо. (за замовчуванням: true)
flight.log_errors - Записувати помилки до файлу журналу помилок веб-сервера. (за замовчуванням: false)
flight.views.path - Директорія, що містить файли шаблонів вигляду. (за замовчуванням: ./views)
flight.views.extension - Розширення файлу шаблону вигляду. (за замовчуванням: .php)
```

## <a name="frameworkmethods"></a> Методи фреймворку

Flight розроблений, щоб бути простим у використанні та розумінні. Наступні є повним
набором методів фреймворку. Він складається з основних методів, які є звичайними
статичними методами, та розширювальних методів, які є відображеними методами, що можуть бути відфільтровані
або переоприділені.

### Основні методи

```php
Flight::map(string $name, callable $callback, bool $pass_route = false) // Створює користувацький метод фреймворку.
Flight::register(string $name, string $class, array $params = [], ?callable $callback = null) // Реєструє клас до методу фреймворку.
Flight::before(string $name, callable $callback) // Додає фільтр перед методом фреймворку.
Flight::after(string $name, callable $callback) // Додає фільтр після методу фреймворку.
Flight::path(string $path) // Додає шлях для автозавантаження класів.
Flight::get(string $key) // Отримує змінну.
Flight::set(string $key, mixed $value) // Встановлює змінну.
Flight::has(string $key) // Перевіряє, чи встановлена змінна.
Flight::clear(array|string $key = []) // Очищає змінну.
Flight::init() // Ініціалізує фреймворк до його стандартних налаштувань.
Flight::app() // Отримує об'єкт екземпляра програми
```

### Розширювальні методи

```php
Flight::start() // Запускає фреймворк.
Flight::stop() // Зупиняє фреймворк і надсилає відповідь.
Flight::halt(int $code = 200, string $message = '') // Зупиніть фреймворк з необов'язковим кодом статусу та повідомленням.
Flight::route(string $pattern, callable $callback, bool $pass_route = false) // Відображає шаблон URL до зворотного виклику.
Flight::group(string $pattern, callable $callback) // Створює групування для URL, шаблон повинен бути рядком.
Flight::redirect(string $url, int $code) // Перенаправляє на інший URL.
Flight::render(string $file, array $data, ?string $key = null) // Відображає файл шаблону.
Flight::error(Throwable $error) // Відправляє відповідь HTTP 500.
Flight::notFound() // Відправляє відповідь HTTP 404.
Flight::etag(string $id, string $type = 'string') // Виконує кешування HTTP ETag.
Flight::lastModified(int $time) // Виконує кешування HTTP останньої модифікації.
Flight::json(mixed $data, int $code = 200, bool $encode = true, string $charset = 'utf8', int $option) // Відправляє JSON-відповідь.
Flight::jsonp(mixed $data, string $param = 'jsonp', int $code = 200, bool $encode = true, string $charset = 'utf8', int $option) // Відправляє JSONP-відповідь.
```

Будь-які користувацькі методи, додані за допомогою `map` і `register`, також можна фільтрувати.

## <a name="frameworkinstance"></a> Екземпляр фреймворку

Замість того, щоб запускати Flight як глобальний статичний клас, ви можете опціонально запускати його
як об'єктний екземпляр.

``` php
require 'flight/autoload.php';

use flight\Engine;

$app = new Engine();

$app->route('/', function(){
    echo 'привіт, світ!';
});

$app->start();
```

Отже, замість того, щоб викликати статичний метод, ви б викликали метод екземпляра з
тим самим ім'ям на об'єкті Engine.
