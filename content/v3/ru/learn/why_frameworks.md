
# Почему фреймворк?

Некоторые программисты решительно против использования фреймворков. Они утверждают, что фреймворки избыточны, медленны и сложны в изучении. 
Они говорят, что фреймворки не нужны, и что можно писать лучший код без них. 
Конечно, есть несколько обоснованных аргументов против использования фреймворков. Однако, есть также много преимуществ в использовании фреймворков. 

## Причины использования фреймворка

Вот несколько причин, почему вам может захотеться рассмотреть использование фреймворка:

- **Быстрая разработка**: Фреймворки предоставляют много функциональности из коробки. Это означает, что вы можете создавать веб-приложения быстрее. Вам не нужно писать столько кода, потому что фреймворк предоставляет много функциональности, которая вам нужна.
- **Согласованность**: Фреймворки предоставляют последовательный способ сделать вещи. Это облегчает понимание работы кода и упрощает другим разработчикам понимание вашего кода. Если у вас есть скрипт за скриптом, вы можете потерять согласованность между скриптами, особенно если вы работаете с командой разработчиков.
- **Безопасность**: Фреймворки предоставляют функции безопасности, которые помогают защитить ваши веб-приложения от распространенных угроз безопасности. Это означает, что вам не нужно беспокоиться о безопасности, потому что фреймворк заботится о большей части этого за вас.
- **Сообщество**: У фреймворков есть большие сообщества разработчиков, которые вносят свой вклад во фреймворк. Это означает, что вы можете получить помощь от других разработчиков, когда у вас возникают вопросы или проблемы. Это также означает, что доступно множество ресурсов для помощи в изучении использования фреймворка.
- **Лучшие практики**: Фреймворки созданы с использованием лучших практик. Это означает, что вы можете учиться у фреймворка и использовать те же лучшие практики в своем собственном коде. Это может помочь вам стать лучшим программистом. Иногда вы не знаете, чего не знаете, и это может вам плохо повлиять в конечном итоге.
- **Расширяемость**: Фреймворки разработаны для расширения. Это означает, что вы можете добавлять свою собственную функциональность в фреймворк. Это позволяет создавать веб-приложения, которые соответствуют вашим конкретным потребностям.

Flight - это микрофреймворк. Это означает, что он небольшой и легкий. Он не предоставляет так много функциональности, как более крупные фреймворки, такие как Laravel или Symfony. 
Однако он предоставляет много функциональности, которая вам нужна для создания веб-приложений. Его также легко изучить и использовать. 
Это делает его хорошим выбором для быстрого и простого создания веб-приложений. Если вы новичок в фреймворках, Flight - отличный фреймворк для начала. 
Он поможет вам узнать о преимуществах использования фреймворков, не перегружая вас слишком сложностью. 
После того как у вас будет опыт работы с Flight, будет легче перейти на более сложные фреймворки, такие как Laravel или Symfony, 
однако Flight все равно может создать успешное надежное приложение.

## Что такое маршрутизация?

Маршрутизация является основой фреймворка Flight, но что это такое? Маршрутизация - это процесс принятия URL и сопоставления его с определенной функцией в вашем коде. 
Таким образом вы можете заставить ваш веб-сайт делать разные вещи в зависимости от запрошенного URL. Например, вы могли бы показать профиль пользователя, когда 
они посещают `/user/1234`, но показать список всех пользователей, когда они посещают `/users`. Все это делается через маршрутизацию.

Это может работать так:

- Пользователь заходит в ваш браузер и вводит `http://example.com/user/1234`.
- Сервер получает запрос, смотрит на URL и передает его в ваш код приложения Flight.
- Предположим, в вашем коде Flight у вас есть что-то вроде `Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);`. Ваш код приложения Flight смотрит на URL и видит, что он соответствует определенному маршруту, затем выполняет код, который вы определили для этого маршрута.  
- Маршрутизатор Flight затем запустится и вызовет метод `viewUserProfile($id)` в классе `UserController`, передавая `1234` в аргумент `$id` метода.
- Код в вашем методе `viewUserProfile()` затем будет выполняться и делать то, что вы ему сказали делать. Вы можете закончить выводом некоторого HTML для страницы профиля пользователя, или если это RESTful API, вы можете вывести JSON-ответ с информацией о пользователе.
- Flight завернет это в красивый бантик, сгенерирует заголовки ответа и отправит обратно в браузер пользователя.
- Пользователь будет полон радости и даст себе теплый объятие!

### И зачем это важно?

Иметь правильный централизованный маршрутизатор может действительно сильно облегчить вашу жизнь! Просто сначала это может быть трудно увидеть. Вот несколько причин:

- **Централизованная маршрутизация**: Вы можете хранить все свои маршруты в одном месте. Это позволяет легче видеть, какие маршруты у вас есть и что они делают. Также это упрощает их изменение, если вам это понадобится.
- **Параметры маршрута**: Вы можете использовать параметры маршрута, чтобы передавать данные в ваши методы маршрутов. Это отличный способ держать ваш код чистым и организованным.
- **Группировка маршрутов**: Вы можете группировать маршруты вместе. Это отлично для организации вашего кода и для применения [middleware](middleware) к группе маршрутов.
- **Псевдонимы маршрутов**: Вы можете присвоить псевдоним маршруту, чтобы URL мог динамически генерироваться позже в вашем коде (например, как шаблон). Например, вместо хардкода `/user/1234` в вашем коде, вы можете обратиться к псевдониму `user_view` и передать `id` как параметр. Это замечательно в случае, если вы решите изменить его на `/admin/user/1234` позднее. Вам не придется изменять все свои жестко закодированные URL, просто URL, привязанный к маршруту.
- **Промежуточное ПО маршрута**: Вы можете добавлять промежуточное программное обеспечение к вашим маршрутам. Промежуточное программное обеспечение невероятно мощно в добавлении определенных поведений к вашему приложению, таких как аутентификация того, что определенный пользователь может получить доступ к маршруту или группе маршрутов.

Я уверен, что вы знакомы со способом создания веб-сайта, описанным скрипт за скриптом. Может быть у вас есть файл под названием `index.php`, который содержит множество условных операторов `if` 
для проверки URL, а затем запуска определенной функции на основе URL. Это форма маршрутизации, но она не очень организована и может 
быстро выйти из-под контроля. Система маршрутизации Flight - это гораздо более организованный и мощный способ управления маршрутами.

Это?

```php

// /user/view_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	viewUserProfile($id);
}

// /user/edit_profile.php?id=1234
if ($_GET['id']) {
	$id = $_GET['id'];
	editUserProfile($id);
}

// и так далее...
```

или это?

```php

// index.php
Flight::route('/user/@id', [ 'UserController', 'viewUserProfile' ]);
Flight::route('/user/@id/edit', [ 'UserController', 'editUserProfile' ]);

// Возможно, в вашем app/controllers/UserController.php
class UserController {
	public function viewUserProfile($id) {
		// сделать что-то
	}

	public function editUserProfile($id) {
		// сделать что-то
	}
}
```

Надеюсь, теперь вы начинаете видеть преимущества использования централизованной системы маршрутизации. Это намного проще управлять и понимать в долгосрочной перспективе!

## Запросы и ответы

Flight предоставляет простой и легкий способ обработки запросов и ответов. Это ядро функционала веб-фреймворка. Он принимает запрос 
от браузера пользователя, обрабатывает его, а затем отправляет ответ. Именно так вы можете создавать веб-приложения, которые показывают профиль пользователя, 
позволяют пользователю войти в систему или опубликовать новый блог.

### Запросы

Запрос - это то, что браузер пользователя отправляет на ваш сервер при посещении вашего веб-сайта. Этот запрос содержит информацию о том, что 
хочет сделать пользователь. Например, он может содержать информацию о том, какой URL пользователь хочет посетить, какие данные пользователь хочет отправить на ваш сервер, 
или какие данные пользователь хочет получить от вашего сервера. Важно знать, что запрос только для чтения. Вы не можете изменить запрос, 
но можете читать его.

Flight предоставляет простой способ получить доступ к информации о запросе. Вы можете получить доступ к информации о запросе, используя метод `Flight::request()` 
Метод возвращает объект `Request`, который содержит информацию о запросе. Вы можете использовать этот объект для доступа к информации о запросе, такой как URL, метод или данные, 
которые пользователь отправил на ваш сервер.

### Ответы

Ответ - это то, что ваш сервер отправляет обратно на браузер пользователя при посещении вашего веб-сайта. Этот ответ содержит информацию о том, что ваш сервер хочет сделать. 
Например, он может содержать информацию о том, какие данные ваш сервер хочет отправить пользователю, какие данные ваш сервер хочет получить от пользователя, 
или какие данные ваш сервер хочет сохранить на компьютере пользователя.

Flight предоставляет простой способ отправить ответ браузеру пользователя. Вы можете отправить ответ, используя метод `Flight::response()` 
Метод принимает объект `Response` в качестве аргумента и отправляет ответ браузеру пользователя. Вы можете использовать этот объект, чтобы отправить ответ браузеру пользователя, 
такой как HTML, JSON или файл. Flight помогает автоматически генерировать некоторые части ответа, чтобы сделать вещи легкими, но в конечном итоге у вас есть 
контроль над тем, что вы отправляете обратно пользователю.
