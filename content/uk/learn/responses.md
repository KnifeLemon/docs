# Відповіді

Flight допомагає генерувати частину заголовків відповіді за вас, але ви контролюєте більшу частину того, що відправляєте назад користувачу. Іноді ви можете отримати об'єкт `Response` безпосередньо, але в більшості випадків ви будете використовувати екземпляр `Flight` для відправки відповіді.

## Надання базової відповіді

Flight використовує ob_start() для буферизації виходу. Це означає, що ви можете використовувати `echo` або `print` для відправки відповіді користувачу, а Flight захопить її і відправить назад користувачу з відповідними заголовками.

```php

// Це надішле "Привіт, Світ!" у браузер користувача
Flight::route('/', function() {
	echo "Привіт, Світ!";
});

// HTTP/1.1 200 OK
// Content-Type: text/html
//
// Привіт, Світ!
```

Як альтернативу, ви можете викликати метод `write()`, щоб додати до тіла.

```php

// Це надішле "Привіт, Світ!" у браузер користувача
Flight::route('/', function() {
	// громіздкий, але виконує завдання, коли вам це потрібно
	Flight::response()->write("Привіт, Світ!");

	// якщо ви хочете отримати тіло, яке ви встановили на цей момент
	// ви можете зробити це так
	$body = Flight::response()->getBody();
});
```

## Коди статусу

Ви можете встановити код статусу відповіді, використовуючи метод `status`:

```php
Flight::route('/@id', function($id) {
	if($id == 123) {
		Flight::response()->status(200);
		echo "Привіт, Світ!";
	} else {
		Flight::response()->status(403);
		echo "Заборонено";
	}
});
```

Якщо ви хочете отримати поточний код статусу, ви можете використовувати метод `status` без аргументів:

```php
Flight::response()->status(); // 200
```

## Встановлення тіла відповіді

Ви можете встановити тіло відповіді, використовуючи метод `write`, однак, якщо ви виведете або надрукуєте будь-що, 
воно буде захоплене і надіслане як тіло відповіді через буферизацію виходу.

```php
Flight::route('/', function() {
	Flight::response()->write("Привіт, Світ!");
});

// те ж саме, що і

Flight::route('/', function() {
	echo "Привіт, Світ!";
});
```

### Очищення тіла відповіді

Якщо ви хочете очистити тіло відповіді, ви можете використовувати метод `clearBody`:

```php
Flight::route('/', function() {
	if($someCondition) {
		Flight::response()->write("Привіт, Світ!");
	} else {
		Flight::response()->clearBody();
	}
});
```

### Запуск зворотного виклику на тілі відповіді

Ви можете виконати зворотний виклик на тілі відповіді, використовуючи метод `addResponseBodyCallback`:

```php
Flight::route('/users', function() {
	$db = Flight::db();
	$users = $db->fetchAll("SELECT * FROM users");
	Flight::render('users_table', ['users' => $users]);
});

// Це стисне всі відповіді для будь-якого маршруту
Flight::response()->addResponseBodyCallback(function($body) {
	return gzencode($body, 9);
});
```

Ви можете додати кілька зворотних викликів, і вони будуть виконуватись в порядку, в якому були додані. Оскільки це може приймати будь-який [callable](https://www.php.net/manual/en/language.types.callable.php), це може приймати масив класу `[ $class, 'method' ]`, замикання `$strReplace = function($body) { str_replace('hi', 'there', $body); };`, або ім'я функції `'minify'`, якщо у вас була функція для мінімізації вашого HTML коду, наприклад.

**Примітка:** Зворотні виклики маршрутів не будуть працювати, якщо ви використовуєте параметр конфігурації `flight.v2.output_buffering`.

### Зворотний виклик для конкретного маршруту

Якщо ви хочете, щоб це стосувалося лише конкретного маршруту, ви можете додати зворотний виклик у сам маршрут:

```php
Flight::route('/users', function() {
	$db = Flight::db();
	$users = $db->fetchAll("SELECT * FROM users");
	Flight::render('users_table', ['users' => $users]);

	// Це стисне лише відповідь для цього маршруту
	Flight::response()->addResponseBodyCallback(function($body) {
		return gzencode($body, 9);
	});
});
```

### Опція проміжного програмного забезпечення

Ви також можете використовувати проміжне програмне забезпечення, щоб застосувати зворотний виклик до всіх маршрутів через проміжне програмне забезпечення:

```php
// MinifyMiddleware.php
class MinifyMiddleware {
	public function before() {
		// Застосуйте зворотний виклик тут до об'єкта response().
		Flight::response()->addResponseBodyCallback(function($body) {
			return $this->minify($body);
		});
	}

	protected function minify(string $body): string {
		// мінімізуйте тіло якимось чином
		return $body;
	}
}

// index.php
Flight::group('/users', function() {
	Flight::route('', function() { /* ... */ });
	Flight::route('/@id', function($id) { /* ... */ });
}, [ new MinifyMiddleware() ]);
```

## Встановлення заголовка відповіді

Ви можете встановити заголовок, наприклад, тип контенту відповіді, використовуючи метод `header`:

```php

// Це надішле "Привіт, Світ!" у браузер користувача у простому тексті
Flight::route('/', function() {
	Flight::response()->header('Content-Type', 'text/plain');
	// або
	Flight::response()->setHeader('Content-Type', 'text/plain');
	echo "Привіт, Світ!";
});
```

## JSON

Flight забезпечує підтримку відправки JSON та JSONP відповідей. Щоб надіслати JSON-відповідь, ви передаєте деякі дані для JSON-кодування:

```php
Flight::json(['id' => 123]);
```

> **Примітка:** За замовчуванням Flight надішле заголовок `Content-Type: application/json` з відповіддю. Він також використовуватиме константи `JSON_THROW_ON_ERROR` та `JSON_UNESCAPED_SLASHES` під час кодування JSON.

### JSON з кодом статусу

Ви також можете передати код статусу як другий аргумент:

```php
Flight::json(['id' => 123], 201);
```

### JSON з красивим форматом

Ви також можете передати аргумент в останню позицію, щоб увімкнути красиве друкування:

```php
Flight::json(['id' => 123], 200, true, 'utf-8', JSON_PRETTY_PRINT);
```

Якщо ви змінюєте параметри, передані в `Flight::json()`, і хочете спростити синтаксис, ви можете 
просто переназначити метод JSON:

```php
Flight::map('json', function($data, $code = 200, $options = 0) {
	Flight::_json($data, $code, true, 'utf-8', $options);
}

// І тепер його можна використовувати так
Flight::json(['id' => 123], 200, JSON_PRETTY_PRINT);
```

### JSON та зупинка виконання (v3.10.0)

Якщо ви хочете надіслати JSON-відповідь і зупинити виконання, ви можете використовувати метод `jsonHalt`. 
Це корисно для випадків, коли ви перевіряєте, чи є якийсь вид авторизації, і якщо
користувач не авторизований, ви можете надіслати JSON-відповідь негайно, очистити існуючий зміст тіла
і зупинити виконання.

```php
Flight::route('/users', function() {
	$authorized = someAuthorizationCheck();
	// Перевірте, чи авторизований користувач
	if($authorized === false) {
		Flight::jsonHalt(['error' => 'Неавторизований'], 401);
	}

	// Продовжте з рештою маршруту
});
```

Перед версією v3.10.0 вам довелося б зробити щось на зразок цього:

```php
Flight::route('/users', function() {
	$authorized = someAuthorizationCheck();
	// Перевірте, чи авторизований користувач
	if($authorized === false) {
		Flight::halt(401, json_encode(['error' => 'Неавторизований']));
	}

	// Продовжте з рештою маршруту
});
```

### JSONP

Для запитів JSONP ви можете опціонально передати ім'я параметра запиту, яке ви використовуєте, щоб визначити свою функцію обратного виклику:

```php
Flight::jsonp(['id' => 123], 'q');
```

Отже, при здійсненні GET запиту з `?q=my_func`, ви повинні отримати вихід:

```javascript
my_func({"id":123});
```

Якщо ви не передасте ім'я параметра запиту, воно за замовчуванням буде `jsonp`.

## Перенаправлення на іншу URL

Ви можете перенаправити поточний запит, використовуючи метод `redirect()` і передаючи
нову URL:

```php
Flight::redirect('/new/location');
```

За замовчуванням Flight надсилає статус-код HTTP 303 ("Дивіться інше"). Ви також можете встановити
кастомний код:

```php
Flight::redirect('/new/location', 401);
```

## Зупинка

Ви можете зупинити фреймворк в будь-який момент, викликаючи метод `halt`:

```php
Flight::halt();
```

Ви також можете вказати необов'язковий `HTTP` статус-код і повідомлення:

```php
Flight::halt(200, 'Зараз повернусь...');
```

Виклик `halt` скине будь-який зміст відповіді до цього моменту. Якщо ви хочете зупинити
фреймворк і вивести поточну відповідь, використовуйте метод `stop`:

```php
Flight::stop();
```

## Очищення даних відповіді

Ви можете очистити тіло відповіді та заголовки, використовуючи метод `clear()`. Це очистить
будь-які заголовки, призначені відповіді, очистить тіло відповіді та встановить код статусу на `200`.

```php
Flight::response()->clear();
```

### Очищення лише тіла відповіді

Якщо ви хочете очистити тільки тіло відповіді, ви можете використовувати метод `clearBody()`:

```php
// Це все ще зберігатиме будь-які заголовки, встановлені на об'єкті response().
Flight::response()->clearBody();
```

## HTTP кешування

Flight забезпечує вбудовану підтримку кешування на рівні HTTP. Якщо умова кешування
виконується, Flight поверне HTTP `304 Not Modified` відповідь. Наступного разу, коли
клієнт запросить той самий ресурс, йому буде запропоновано використовувати локально
збережену версію.

### Кешування на рівні маршруту

Якщо ви хочете кешувати всю відповідь, ви можете використовувати метод `cache()` і передати час для кешування.

```php

// Це кешуватиме відповідь на 5 хвилин
Flight::route('/news', function () {
  Flight::response()->cache(time() + 300);
  echo 'Цей контент буде кешовано.';
});

// Або ви можете використовувати рядок, який будете передавати
// методу strtotime()
Flight::route('/news', function () {
  Flight::response()->cache('+5 minutes');
  echo 'Цей контент буде кешовано.';
});
```

### Остання модифікація

Ви можете використовувати метод `lastModified` і передати UNIX-тимчасову мітку, щоб встановити дату
та час, коли сторінка була останній раз модифікована. Клієнт продовжить використовувати свій кеш, поки
значення останньої модифікації не зміниться.

```php
Flight::route('/news', function () {
  Flight::lastModified(1234567890);
  echo 'Цей контент буде кешовано.';
});
```

### ETag

Кешування `ETag` схоже на `Last-Modified`, за винятком того, що ви можете вказати будь-який ідентифікатор, 
який хочете для ресурсу:

```php
Flight::route('/news', function () {
  Flight::etag('my-unique-id');
  echo 'Цей контент буде кешовано.';
});
```

Не забувайте, що виклик або `lastModified`, або `etag` буде як встановлювати, так і перевіряти
значення кешу. Якщо значення кешу однакове між запитами, Flight негайно
відправить відповідь `HTTP 304` і припинить обробку.

## Завантаження файлу (v3.12.0)

Є допоміжний метод для завантаження файлу. Ви можете використовувати метод `download` і передати шлях.

```php
Flight::route('/download', function () {
  Flight::download('/path/to/file.txt');
});
```