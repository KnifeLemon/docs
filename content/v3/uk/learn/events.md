# Менеджер подій

_станом на v3.15.0_

## Огляд

Події дозволяють реєструвати та активувати власну поведінку у вашому додатку. З додаванням `Flight::onEvent()` та `Flight::triggerEvent()`, ви тепер можете підключатися до ключових моментів життєвого циклу вашого додатку або визначати власні події (наприклад, сповіщення та email) для того, щоб зробити ваш код більш модульним та розширюваним. Ці методи є частиною [mappable methods](/learn/extending) у Flight, що означає, що ви можете перевизначити їхню поведінку відповідно до ваших потреб.

## Розуміння

Події дозволяють розділяти різні частини вашого додатку, щоб вони не залежали надто сильно одна від одної. Це розділення — часто називається **розв’язанням залежностей** — робить ваш код легшим для оновлення, розширення або налагодження. Замість того, щоб писати все в одному великому блоці, ви можете розбити вашу логіку на менші, незалежні частини, які реагують на конкретні дії (події).

Уявіть, що ви будуєте додаток для блогу:
- Коли користувач публікує коментар, ви можете захотіти:
  - Зберегти коментар у базі даних.
  - Надіслати email власнику блогу.
  - Записати дію для безпеки.

Без подій ви б запхали все це в одну функцію. З подіями ви можете розбити це: одна частина зберігає коментар, інша активує подію на кшталт `'comment.posted'`, а окремі слухачі обробляють email та логування. Це робить ваш код чистішим та дозволяє додавати або видаляти функції (наприклад, сповіщення) без дотику до основної логіки.

### Поширені випадки використання

У більшості випадків події корисні для речей, які є необов’язковими, але не є абсолютною основною частиною вашої системи. Наприклад, наступні є хорошими для наявності, але якщо вони з якихось причин не спрацюють, ваш додаток все одно повинен працювати:

- **Логування**: Записувати дії на кшталт логінів або помилок без засмічення основного коду.
- **Сповіщення**: Надсилати email або сповіщення, коли щось відбувається.
- **Оновлення кешу**: Оновлювати кеш або сповіщати інші системи про зміни.

Однак уявіть, що у вас є функція "забули пароль". Це повинно бути частиною вашої основної функціональності, а не подією, бо якщо той email не буде надісланий, користувач не зможе скинути пароль та використовувати ваш додаток.

## Основне використання

Система подій у Flight побудована навколо двох основних методів: `Flight::onEvent()` для реєстрації слухачів подій та `Flight::triggerEvent()` для активації подій. Ось як ви можете їх використовувати:

### Реєстрація слухачів подій

Щоб слухати подію, використовуйте `Flight::onEvent()`. Цей метод дозволяє вам визначити, що повинно відбуватися, коли подія виникає.

```php
Flight::onEvent(string $event, callable $callback): void
```

- `$event`: Назва для вашої події (наприклад, `'user.login'`).
- `$callback`: Функція, яка виконується, коли подія активується.

Ви "підписуєтеся" на подію, повідомляючи Flight, що робити, коли вона відбувається. Callback може приймати аргументи, передані від активатора події.

Система подій у Flight є синхронною, що означає, що кожен слухач події виконується послідовно, один за одним. Коли ви активуєте подію, всі зареєстровані слухачі для цієї події виконаються до завершення, перш ніж ваш код продовжиться. Це важливо розуміти, оскільки це відрізняється від асинхронних систем подій, де слухачі можуть виконуватися паралельно або пізніше.

#### Простий приклад
```php
Flight::onEvent('user.login', function ($username) {
    echo "Ласкаво просимо назад, $username!";

	// ви можете надіслати email, якщо логін з нового місця
});
```
Тут, коли подія `'user.login'` активується, вона привітає користувача по імені та може також включати логіку для надсилання email, якщо потрібно.

> **Примітка:** Callback може бути функцією, анонімною функцією або методом з класу.

### Активація подій

Щоб зробити подію, використовуйте `Flight::triggerEvent()`. Це повідомляє Flight виконати всіх слухачів, зареєстрованих для цієї події, передаючи будь-які дані, які ви надаєте.

```php
Flight::triggerEvent(string $event, ...$args): void
```

- `$event`: Назва події, яку ви активуєте (має відповідати зареєстрованій події).
- `...$args`: Необов’язкові аргументи для надсилання слухачам (може бути будь-яка кількість аргументів).

#### Простий приклад
```php
$username = 'alice';
Flight::triggerEvent('user.login', $username);
```
Це активує подію `'user.login'` та надсилає `'alice'` слухачу, який ми визначили раніше, що виведе: `Ласкаво просимо назад, alice!`.

- Якщо немає зареєстрованих слухачів, нічого не відбувається — ваш додаток не зламається.
- Використовуйте оператор розширення (`...`) для гнучкого передавання кількох аргументів.

### Зупинка подій

Якщо слухач повертає `false`, жодні додаткові слухачі для цієї події не будуть виконані. Це дозволяє зупинити ланцюг подій на основі конкретних умов. Пам’ятайте, порядок слухачів має значення, оскільки перший, що поверне `false`, зупинить решту від виконання.

**Приклад**:
```php
Flight::onEvent('user.login', function ($username) {
    if (isBanned($username)) {
        logoutUser($username);
        return false; // Зупиняє наступних слухачів
    }
});
Flight::onEvent('user.login', function ($username) {
    sendWelcomeEmail($username); // це ніколи не надсилається
});
```

### Перевизначення методів подій

`Flight::onEvent()` та `Flight::triggerEvent()` доступні для [розширення](/learn/extending), що означає, що ви можете перевизначити, як вони працюють. Це чудово для просунутих користувачів, які хочуть налаштувати систему подій, наприклад, додавши логування або змінивши, як події розподіляються.

#### Приклад: Налаштування `onEvent`
```php
Flight::map('onEvent', function (string $event, callable $callback) {
    // Логувати кожну реєстрацію події
    error_log("Додано нового слухача події для: $event");
    // Викликати поведінку за замовчуванням (припускаючи внутрішню систему подій)
    Flight::_onEvent($event, $callback);
});
```
Тепер щоразу, коли ви реєструєте подію, вона логуватиметься перед продовженням.

#### Чому перевизначати?
- Додати налагодження або моніторинг.
- Обмежити події в певних середовищах (наприклад, вимкнути в тестуванні).
- Інтегрувати з іншою бібліотекою подій.

### Де розміщувати ваші події

Якщо ви новачок у концепціях подій у вашому проекті, ви можете запитати: *де я реєструю всі ці події в моєму додатку?* Простота Flight означає, що немає суворого правила — ви можете розміщувати їх де завгодно, що має сенс для вашого проекту. Однак, організація їх допомагає підтримувати код, коли додаток росте. Ось деякі практичні опції та найкращі практики, адаптовані до легкої природи Flight:

#### Опція 1: У вашому основному `index.php`
Для маленьких додатків або швидких прототипів ви можете реєструвати події прямо у файлі `index.php` поряд з маршрутами. Це тримає все в одному місці, що нормально, коли пріоритет — простота.

```php
require 'vendor/autoload.php';

// Реєстрація подій
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов о " . date('Y-m-d H:i:s'));
});

// Визначення маршрутів
Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Увійшов!";
});

Flight::start();
```
- **Переваги**: Просто, без додаткових файлів, чудово для маленьких проектів.
- **Недоліки**: Може стати безладним, коли додаток росте з більше подіями та маршрутами.

#### Опція 2: Окремий файл `events.php`
Для трохи більшого додатку розгляньте перенесення реєстрацій подій у спеціальний файл на кшталт `app/config/events.php`. Включіть цей файл у ваш `index.php` перед маршрутами. Це імітує, як часто організовані маршрути в `app/config/routes.php` у проектах Flight.

```php
// app/config/events.php
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов о " . date('Y-m-d H:i:s'));
});

Flight::onEvent('user.registered', function ($email, $name) {
    echo "Email надіслано $email: Ласкаво просимо, $name!";
});
```

```php
// index.php
require 'vendor/autoload.php';
require 'app/config/events.php';

Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Увійшов!";
});

Flight::start();
```
- **Переваги**: Тримає `index.php` зосередженим на маршрутизації, організовує події логічно, легко знайти та редагувати.
- **Недоліки**: Додає крихітну структуру, що може здаватися надмірним для дуже маленьких додатків.

#### Опція 3: Близько до місця активації
Інший підхід — реєструвати події близько до місця їх активації, наприклад, всередині контролера або визначення маршруту. Це добре працює, якщо подія специфічна для однієї частини вашого додатку.

```php
Flight::route('/signup', function () {
    // Реєстрація події тут
    Flight::onEvent('user.registered', function ($email) {
        echo "Ласкаво просимо email надіслано $email!";
    });

    $email = 'jane@example.com';
    Flight::triggerEvent('user.registered', $email);
    echo "Зареєстровано!";
});
```
- **Переваги**: Тримає пов’язаний код разом, добре для ізольованих функцій.
- **Недоліки**: Розкидує реєстрації подій, роблячи важчим побачити всі події одразу; ризикує дублюванням реєстрацій, якщо не обережно.

#### Найкраща практика для Flight
- **Починайте просто**: Для крихітних додатків розміщуйте події в `index.php`. Це швидко та узгоджується з мінімалізмом Flight.
- **Ростіть розумно**: Коли додаток розширюється (наприклад, більше 5-10 подій), використовуйте файл `app/config/events.php`. Це природний крок вгору, як організація маршрутів, і тримає код охайним без додавання складних фреймворків.
- **Уникайте надмірної інженерії**: Не створюйте повноцінний клас "менеджер подій" або директорію, якщо додаток не величезний — Flight процвітає на простоті, тож тримайте це легким.

#### Порада: Групуйте за призначенням
У `events.php` групуйте пов’язані події (наприклад, всі події, пов’язані з користувачем, разом) з коментарями для ясності:

```php
// app/config/events.php
// Події користувача
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов");
});
Flight::onEvent('user.registered', function ($email) {
    echo "Ласкаво просимо $email!";
});

// Події сторінки
Flight::onEvent('page.updated', function ($pageId) {
    Flight::cache()->delete("page_$pageId");
});
```

Ця структура добре масштабується та залишається дружньою для початківців.

### Приклади з реального світу

Давайте пройдемося по деяких сценаріях з реального світу, щоб показати, як працюють події та чому вони корисні.

#### Приклад 1: Логування входу користувача
```php
// Крок 1: Реєстрація слухача
Flight::onEvent('user.login', function ($username) {
    $time = date('Y-m-d H:i:s');
    error_log("$username увійшов о $time");
});

// Крок 2: Активація в додатку
Flight::route('/login', function () {
    $username = 'bob'; // Уявіть, що це з форми
    Flight::triggerEvent('user.login', $username);
    echo "Привіт, $username!";
});
```
**Чому це корисно**: Код входу не потребує знати про логування — він просто активує подію. Ви можете пізніше додати більше слухачів (наприклад, надіслати email привітання) без зміни маршруту.

#### Приклад 2: Сповіщення про нових користувачів
```php
// Слухач для нових реєстрацій
Flight::onEvent('user.registered', function ($email, $name) {
    // Симулювати надсилання email
    echo "Email надіслано $email: Ласкаво просимо, $name!";
});

// Активація, коли хтось реєструється
Flight::route('/signup', function () {
    $email = 'jane@example.com';
    $name = 'Jane';
    Flight::triggerEvent('user.registered', $email, $name);
    echo "Дякуємо за реєстрацію!";
});
```
**Чому це корисно**: Логіка реєстрації зосереджена на створенні користувача, тоді як подія обробляє сповіщення. Ви можете додати більше слухачів (наприклад, залогувати реєстрацію) пізніше.

#### Приклад 3: Очищення кешу
```php
// Слухач для очищення кешу
Flight::onEvent('page.updated', function ($pageId) {
	// якщо використовуєте плагін flightphp/cache
    Flight::cache()->delete("page_$pageId");
    echo "Кеш очищено для сторінки $pageId.";
});

// Активація при редагуванні сторінки
Flight::route('/edit-page/(@id)', function ($pageId) {
    // Уявіть, що ми оновили сторінку
    Flight::triggerEvent('page.updated', $pageId);
    echo "Сторінка $pageId оновлена.";
});
```
**Чому це корисно**: Код редагування не турбується про кешування — він просто сигналізує оновлення. Інші частини додатку можуть реагувати за потреби.

### Найкращі практики

- **Називайте події ясно**: Використовуйте конкретні назви на кшталт `'user.login'` або `'page.updated'`, щоб було очевидно, що вони роблять.
- **Тримайте слухачів простими**: Не розміщуйте повільні або складні завдання в слухачах — тримайте додаток швидким.
- **Тестуйте ваші події**: Активуйте їх вручну, щоб переконатися, що слухачі працюють як очікується.
- **Використовуйте події розумно**: Вони чудові для розв’язання залежностей, але забагато може зробити код важким для слідкування — використовуйте їх, коли це має сенс.

Система подій у Flight PHP з `Flight::onEvent()` та `Flight::triggerEvent()` дає вам простий, але потужний спосіб будувати гнучкі додатки. Дозволяючи різним частинам додатку спілкуватися через події, ви можете тримати код організованим, повторно використовуваним та легким для розширення. Чи то логування дій, надсилання сповіщень, чи керування оновленнями, події допомагають робити це без заплутування логіки. Плюс, з можливістю перевизначення цих методів, у вас є свобода налаштувати систему під ваші потреби. Почніть з однієї події та спостерігайте, як це трансформує структуру вашого додатку!

### Вбудовані події

Flight PHP має кілька вбудованих подій, які ви можете використовувати для підключення до життєвого циклу фреймворку. Ці події активуються в конкретних точках циклу запит/відповідь, дозволяючи виконувати власну логіку, коли певні дії відбуваються.

#### Список вбудованих подій
- **flight.request.received**: `function(Request $request)` Активується, коли запит отримано, розібрано та оброблено.
- **flight.error**: `function(Throwable $exception)` Активується, коли виникає помилка під час життєвого циклу запиту.
- **flight.redirect**: `function(string $url, int $status_code)` Активується, коли ініціюється перенаправлення.
- **flight.cache.checked**: `function(string $cache_key, bool $hit, float $executionTime)` Активується, коли кеш перевіряється для конкретного ключа та чи був кеш хітом чи місом.
- **flight.middleware.before**: `function(Route $route)` Активується після виконання middleware перед.
- **flight.middleware.after**: `function(Route $route)` Активується після виконання middleware після.
- **flight.middleware.executed**: `function(Route $route, $middleware, string $method, float $executionTime)` Активується після виконання будь-якого middleware.
- **flight.route.matched**: `function(Route $route)` Активується, коли маршрут збігається, але ще не запущено.
- **flight.route.executed**: `function(Route $route, float $executionTime)` Активується після виконання та обробки маршруту. `$executionTime` — час, витрачений на виконання маршруту (виклик контролера тощо).
- **flight.view.rendered**: `function(string $template_file_path, float $executionTime)` Активується після рендерингу view. `$executionTime` — час, витрачений на рендеринг шаблону. **Примітка: Якщо ви перевизначаєте метод `render`, вам потрібно буде повторно активувати цю подію.**
- **flight.response.sent**: `function(Response $response, float $executionTime)` Активується після надсилання відповіді клієнту. `$executionTime` — час, витрачений на побудову відповіді.

## Дивіться також
- [Extending Flight](/learn/extending) - Як розширювати та налаштовувати основну функціональність Flight.
- [Cache](/awesome-plugins/php_file_cache) - Приклад використання подій для очищення кешу при оновленні сторінки.

## Вирішення проблем
- Якщо ви не бачите виклику ваших слухачів подій, переконайтеся, що реєструєте їх перед активацією подій. Порядок реєстрації має значення.

## Журнал змін
- v3.15.0 - Додано події до Flight.