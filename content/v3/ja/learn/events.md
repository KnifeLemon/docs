# Flight PHPにおけるイベントシステム (v3.15.0+)

Flight PHPは、アプリケーション内でカスタムイベントを登録およびトリガーできる軽量で直感的なイベントシステムを導入します。 `Flight::onEvent()` および `Flight::triggerEvent()` の追加により、アプリのライフサイクルの重要な瞬間にフックしたり、自分のイベントを定義したりして、コードをよりモジュール化および拡張可能にすることができます。これらのメソッドはFlightの**マッパブルメソッド**の一部であり、必要に応じてその動作をオーバーライドできます。

このガイドでは、イベントの価値、使用方法、および初心者がその力を理解するのに役立つ実践的な例を含め、イベントの使用を開始するために必要なすべての情報をカバーします。

## なぜイベントを使用するのか？

イベントは、アプリケーションの異なる部分を分離して、それぞれが過度に依存しないようにします。この分離は、しばしば**デカップリング**と呼ばれ、コードの更新、拡張、デバッグを容易にします。すべてを大きな塊で書く代わりに、特定のアクション（イベント）に応答する小さく独立したロジックに分割できます。

ブログアプリを構築していると想像してください：
- ユーザーがコメントを投稿したとき、次のことを行いたいかもしれません：
  - コメントをデータベースに保存する。
  - ブログの所有者にメールを送信する。
  - セキュリティのためにアクションを記録する。

イベントがないと、すべてを1つの関数に無理やり詰め込むことになります。イベントを使用すると、コメントを保存する部分、`'comment.posted'`のようなイベントをトリガーする部分、そしてメールやログを処理するリスナーを別々に設けることができます。これにより、コードがすっきりし、コアのロジックに触れずに機能（通知など）を追加または削除できます。

### 一般的な使用例
- **ロギング**：ログインやエラーのようなアクションを記録し、メインのコードを混乱させずに済みます。
- **通知**：何かが発生したときにメールやアラートを送信します。
- **更新**：キャッシュを更新したり、他のシステムに変更を通知したりします。

## イベントリスナーの登録

イベントをリッスンするには、`Flight::onEvent()`を使用します。このメソッドは、イベントが発生したときに何が起こるべきかを定義することを可能にします。

### 構文
```php
Flight::onEvent(string $event, callable $callback): void
```
- `$event`：イベントの名前（例：`'user.login'`）。
- `$callback`：イベントがトリガーされたときに実行する関数。

### 仕組み
あなたは、イベントが発生したときにFlightに何をするかを知らせることで、「サブスクライブ」します。コールバックは、イベントトリガーから渡される引数を受け取ることができます。

Flightのイベントシステムは同期的であり、これは各イベントリスナーが順次実行され、1つずつ処理されることを意味します。イベントをトリガーすると、そのイベントのすべての登録されたリスナーが実行を完了するまで、あなたのコードは続行しません。これは非同期イベントシステムとは異なり、リスナーが並行して動作したり、後で実行される可能性があるため、理解することが重要です。

### 簡単な例
```php
Flight::onEvent('user.login', function ($username) {
    echo "お帰りなさい、$username!";
});
```
ここでは、`'user.login'`イベントがトリガーされると、ユーザーの名前で挨拶します。

### 重要なポイント
- 同じイベントに複数のリスナーを追加できます。リスナーは登録した順番で実行されます。
- コールバックは関数、無名関数、またはクラスのメソッドである可能性があります。

## イベントをトリガーする

イベントを発生させるには、`Flight::triggerEvent()`を使用します。これにより、Flightはそのイベントのために登録されたすべてのリスナーを実行し、提供されたデータを渡します。

### 構文
```php
Flight::triggerEvent(string $event, ...$args): void
```
- `$event`：トリガーしているイベントの名前（登録されたイベントと一致する必要があります）。
- `...$args`：リスナーに送信するオプションの引数（任意の数の引数が可能です）。

### 簡単な例
```php
$username = 'alice';
Flight::triggerEvent('user.login', $username);
```
これは、`'user.login'`イベントをトリガーし、先に定義したリスナーに`'alice'`を送信します。その結果、`お帰りなさい、alice!`と出力されます。

### 重要なポイント
- リスナーが登録されていない場合、何も起こりません—アプリは壊れません。
- スプレッドオペレーター（`...`）を使用して、柔軟に複数の引数を渡します。

### イベントリスナーの登録

...

**さらなるリスナーの停止**：
リスナーが `false` を返すと、そのイベントの追加のリスナーは実行されません。これは、特定の条件に基づいてイベントチェーンを停止することを可能にします。リスナーの順序は重要です。最初に`false`を返すリスナーが、他のリスナーの実行を停止します。

**例**：
```php
Flight::onEvent('user.login', function ($username) {
    if (isBanned($username)) {
        logoutUser($username);
        return false; // 続くリスナーを停止
    }
});
Flight::onEvent('user.login', function ($username) {
    sendWelcomeEmail($username); // これは送信されない
});
```

## イベントメソッドのオーバーライド

`Flight::onEvent()`および`Flight::triggerEvent()`は[拡張可能](/learn/extending)であり、それらの動作を再定義できます。これは、イベントシステムをカスタマイズしたい上級ユーザーにとって非常に便利です。たとえば、ロギングを追加したり、イベントのディスパッチ方法を変更したりできます。

### 例：`onEvent`のカスタマイズ
```php
Flight::map('onEvent', function (string $event, callable $callback) {
    // すべてのイベント登録をログに記録
    error_log("新しいイベントリスナーが追加されました: $event");
    // デフォルトの動作を呼び出します（内部イベントシステムを仮定）
    Flight::_onEvent($event, $callback);
});
```
これで、イベントを登録するたびに、それをログに記録してから続行します。

### なぜオーバーライドするのか？
- デバッグやモニタリングを追加するため。
- 特定の環境でイベントを制限するため（例：テスト中に無効にする）。
- 別のイベントライブラリと統合するため。

## イベントをどこに置くべきか

初心者として、*アプリにこれらすべてのイベントをどこに登録すればよいのか？* Flightのシンプルさは厳格なルールがないことを意味します。プロジェクトにとって合理的な場所に配置できます。しかし、整理された状態を保つことで、アプリが成長するときにコードを維持しやすくなります。以下は、Flightの軽量な特性に合わせた実践的なオプションとベストプラクティスです。

### オプション 1: メインの`index.php`に
小さなアプリやクイックプロトタイプでは、ルートと同じく`index.php`ファイル内でイベントを登録できます。これは、シンプルさを重視する場合には良い方法です。

```php
require 'vendor/autoload.php';

// イベントを登録
Flight::onEvent('user.login', function ($username) {
    error_log("$username が " . date('Y-m-d H:i:s') . " にログインしました");
});

// ルートを定義
Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "ログインしました!";
});

Flight::start();
```
- **長所**：シンプルで追加ファイルなし、小さなプロジェクトに最適。
- **短所**：イベントとルートが増えると混沌とする可能性。

### オプション 2: 別の`events.php`ファイル
少し大きなアプリでは、`app/config/events.php`のような専用ファイルにイベント登録を移動することを検討してください。このファイルを`index.php`内のルートの前に含めます。これは、Flightプロジェクトでのルートが`app/config/routes.php`に整理されているのと類似しています。

```php
// app/config/events.php
Flight::onEvent('user.login', function ($username) {
    error_log("$username が " . date('Y-m-d H:i:s') . " にログインしました");
});

Flight::onEvent('user.registered', function ($email, $name) {
    echo "$email宛にメールを送信しました: ようこそ、$nameさん!";
});
```

```php
// index.php
require 'vendor/autoload.php';
require 'app/config/events.php';

Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "ログインしました!";
});

Flight::start();
```
- **長所**：`index.php`がルーティングに集中できる、論理的にイベントを整理、見つけやすく編集しやすい。
- **短所**：若干の構造的な追加があり、小さなアプリには過剰に感じることも。

### オプション 3: トリガー近くに
別のアプローチは、トリガーされる場所の近くでイベントを登録することです。コントローラーやルート定義の中で行います。これは、イベントがアプリの特定の部分に特有である場合に効果的です。

```php
Flight::route('/signup', function () {
    // ここでイベントを登録
    Flight::onEvent('user.registered', function ($email) {
        echo "$email宛にようこそメールが送信されました!";
    });

    $email = 'jane@example.com';
    Flight::triggerEvent('user.registered', $email);
    echo "サインアップしました!";
});
```
- **長所**：関連するコードを一緒に保つ、孤立した機能に良い。
- **短所**：イベント登録が散在し、すべてのイベントを一度に見るのが難しくなる; 慎重でないと重複登録のリスクがあります。

### Flightのベストプラクティス
- **シンプルに始める**：小さなアプリでは、`index.php`にイベントを配置します。これが迅速でFlightのミニマリズムに沿っています。
- **スマートに成長する**：アプリが拡大する場合（例：5-10のイベント以上）、`app/config/events.php`ファイルを使用します。これはルートを整理するような自然なステップであり、複雑なフレームワークを追加することなくコードをすっきり保ってくれます。
- **過剰設計を避ける**：アプリが巨大になるまで、完全な「イベントマネージャ」クラスやディレクトリを作成しないでください—Flightはシンプルさを重視しているので、軽量に保ってください。

### ヒント：目的別にグループ化
`events.php`内で、関連するイベント（例：すべてのユーザー関連イベントを一緒に）をコメントでグループ化します：

```php
// app/config/events.php
// ユーザーイベント
Flight::onEvent('user.login', function ($username) {
    error_log("$username がログインしました");
});
Flight::onEvent('user.registered', function ($email) {
    echo "$emailへようこそ!";
});

// ページイベント
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]);
});
```

この構造はスケールしやすく、初心者にも優しいです。

## 初心者向けの例

いくつかの実世界のシナリオを通じて、イベントがどのように機能し、なぜ役立つのかを示しましょう。

### 例 1: ユーザーログインのロギング
```php
// ステップ 1: リスナーを登録
Flight::onEvent('user.login', function ($username) {
    $time = date('Y-m-d H:i:s');
    error_log("$username が $time にログインしました");
});

// ステップ 2: アプリ内でトリガーする
Flight::route('/login', function () {
    $username = 'bob'; // これはフォームから来たと仮定
    Flight::triggerEvent('user.login', $username);
    echo "こんにちは、$username!";
});
```
**なぜ役立つのか**：ログインコードはロギングのことを考える必要がなく、ただイベントをトリガーします。後で、他のリスナー（例：ウェルカムメールを送信）を追加できるのです。

### 例 2: 新しいユーザーについて通知
```php
// 新しい登録のリスナー
Flight::onEvent('user.registered', function ($email, $name) {
    // メールを送信するシミュレーション
    echo "$email宛にメールが送信されました: ようこそ、$nameさん!";
});

// 誰かがサインアップするときにトリガー
Flight::route('/signup', function () {
    $email = 'jane@example.com';
    $name = 'Jane';
    Flight::triggerEvent('user.registered', $email, $name);
    echo "サインアップありがとうございました!";
});
```
**なぜ役立つのか**：サインアップのロジックはユーザーの作成に集中し、イベントが通知を処理します。後で、他のリスナー（例：サインアップをログに記録）を追加できます。

### 例 3: キャッシュをクリアする
```php
// キャッシュをクリアするリスナー
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]); // 該当する場合、セッションキャッシュをクリア
    echo "$pageIdのキャッシュがクリアされました。";
});

// ページが編集されるときにトリガー
Flight::route('/edit-page/(@id)', function ($pageId) {
    // ページを更新したと仮定
    Flight::triggerEvent('page.updated', $pageId);
    echo "$pageIdページが更新されました。";
});
```
**なぜ役立つのか**：編集コードはキャッシングのことを考える必要がなく、更新を信号として発信します。他のアプリの部分が必要に応じて反応できます。

## ベストプラクティス

- **イベント名を明確に**：`'user.login'`や`'page.updated'`のように具体的な名前を使用してください。どのような役割か明確になるので。
- **リスナーをシンプルに保つ**：リスナー内に遅いまたは複雑なタスクを置かないように—アプリを速く保ちます。
- **イベントをテストする**：手動でトリガーして、リスナーが期待通りに機能することを確認してください。
- **イベントを適切に使用する**：デカップリングには優れていますが、多すぎるとコードが追いにくくなることがあるため、意味があるときに使用してください。

`Flight::onEvent()`と`Flight::triggerEvent()`によるFlight PHPのイベントシステムは、柔軟なアプリケーションを構築するためのシンプルでありながら強力な方法を提供します。アプリの異なる部分がイベントを通じてお互いに話し合うことを可能にすることにより、コードを整理し、再利用可能で、拡張しやすくできます。アクションを記録したり、通知を送信したり、更新を管理したりする際に、ロジックを絡ませることなく行うのに役立ちます。さらに、これらのメソッドをオーバーライドできることで、ニーズに合わせてシステムをカスタマイズする自由があります。最初は単一のイベントから始め、その後アプリの構造がどのように変わっていくかを見てみてください。

## ビルトインイベント

Flight PHPには、フレームワークのライフサイクルにフックするために使用できるいくつかのビルトインイベントがあります。これらのイベントは、リクエスト/レスポンスサイクルの特定のポイントでトリガーされ、特定のアクションが発生したときにカスタムロジックを実行することを可能にします。

### ビルトインイベント一覧
- `flight.request.received`：リクエストが受信され、解析され、処理されたときにトリガーされます。
- `flight.route.middleware.before`：beforeミドルウェアが実行された後にトリガーされます。
- `flight.route.middleware.after`：afterミドルウェアが実行された後にトリガーされます。
- `flight.route.executed`：ルートが実行され、処理された後にトリガーされます。
- `flight.response.sent`：レスポンスがクライアントに送信された後にトリガーされます。