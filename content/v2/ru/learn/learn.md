# Учебник

Эта страница является руководством по изучению Flight. Она охватывает основы фреймворка и то, как его использовать.

## <a name="routing"></a> Маршрутизация

Маршрутизация в Flight осуществляется путем сопоставления шаблона URL с функцией обратного вызова.

``` php
Flight::route('/', function(){
    echo 'привет мир!';
});
```

Обратный вызов может быть любым объектом, который можно вызывать. Таким образом, вы можете использовать обычную функцию:

``` php
function hello(){
    echo 'привет мир!';
}

Flight::route('/', 'hello');
```

Или метод класса:

``` php
class Greeting {
    public static function hello() {
        echo 'привет мир!';
    }
}

Flight::route('/', array('Greeting','hello'));
```

Или метод объекта:

``` php
class Greeting
{
    public function __construct() {
        $this->name = 'Джон Доу';
    }

    public function hello() {
        echo "Привет, {$this->name}!";
    }
}

$greeting = new Greeting();

Flight::route('/', array($greeting, 'hello'));
```

Маршруты сопоставляются в том порядке, в котором они определены. Первый маршрут, который соответствует запросу, будет вызван.

### Метод маршрутизации

По умолчанию шаблоны маршрутов сопоставляются со всеми методами запроса. Вы можете отвечать только на определенные методы, поставив идентификатор перед URL.

``` php
Flight::route('GET /', function(){
    echo 'Я получил GET запрос.';
});

Flight::route('POST /', function(){
    echo 'Я получил POST запрос.';
});
```

Вы также можете сопоставить несколько методов с одним и тем же обратным вызовом, используя разделитель `|`:

``` php
Flight::route('GET|POST /', function(){
    echo 'Я получил либо GET, либо POST запрос.';
});
```

### Регулярные выражения

Вы можете использовать регулярные выражения в ваших маршрутах:

``` php
Flight::route('/user/[0-9]+', function(){
    // Это будет соответствовать /user/1234
});
```

### Именованные параметры

Вы можете указать именованные параметры в ваших маршрутах, которые будут переданы в вашу функцию обратного вызова.

``` php
Flight::route('/@name/@id', function($name, $id){
    echo "привет, $name ($id)!";
});
```

Вы также можете включить регулярные выражения вместе с вашими именованными параметрами, используя разделитель `:`:

``` php
Flight::route('/@name/@id:[0-9]{3}', function($name, $id){
    // Это будет соответствовать /bob/123
    // Но не будет соответствовать /bob/12345
});
```

### Опциональные параметры

Вы можете указать именованные параметры, которые являются опциональными для сопоставления, обернув сегменты в круглые скобки.

``` php
Flight::route('/blog(/@year(/@month(/@day)))', function($year, $month, $day){
    // Это будет соответствовать следующим URL:
    // /blog/2012/12/10
    // /blog/2012/12
    // /blog/2012
    // /blog
});
```

Любые опциональные параметры, которые не сопоставлены, будут переданы как NULL.

### Символы подстановки

Сопоставление осуществляется только по отдельным сегментам URL. Если вы хотите сопоставить несколько сегментов, вы можете использовать символ подстановки `*`.

``` php
Flight::route('/blog/*', function(){
    // Это будет соответствовать /blog/2000/02/01
});
```

Чтобы направить все запросы на один обратный вызов, вы можете сделать это:

``` php
Flight::route('*', function(){
    // Сделать что-то
});
```

### Передача

Вы можете передать выполнение следующему соответствующему маршруту, вернув `true` из вашей функции обратного вызова.

``` php
Flight::route('/user/@name', function($name){
    // Проверьте некоторое условие
    if ($name != "Bob") {
        // Продолжить к следующему маршруту
        return true;
    }
});

Flight::route('/user/*', function(){
    // Это будет вызвано
});
```

### Информация о маршруте

Если вы хотите просмотреть информацию о соответствующем маршруте, вы можете запросить, чтобы объект маршрута был передан в вашу функцию обратного вызова, передав `true` в качестве третьего параметра в метод маршрута. Объект маршрута всегда будет последним параметром, переданным в вашу функцию обратного вызова.

``` php
Flight::route('/', function($route){
    // Массив методов HTTP
    $route->methods;

    // Массив именованных параметров
    $route->params;

    // Соответствующее регулярное выражение
    $route->regex;

    // Содержит данные любого '*' используемого в шаблоне URL
    $route->splat;
}, true);
```
### Группировка маршрутов

Могут быть времена, когда вы захотите сгруппировать связанные маршруты вместе (например, `/api/v1`).
Вы можете сделать это, используя метод `group`:

```php
Flight::group('/api/v1', function () {
  Flight::route('/users', function () {
    // Соответствует /api/v1/users
  });

  Flight::route('/posts', function () {
    // Соответствует /api/v1/posts
  });
});
```

Вы даже можете вложить группы в группы:

```php
Flight::group('/api', function () {
  Flight::group('/v1', function () {
    // Flight::get() получает переменные, а не устанавливает маршрут! См. объектный контекст ниже
    Flight::route('GET /users', function () {
      // Соответствует GET /api/v1/users
    });

    Flight::post('/posts', function () {
      // Соответствует POST /api/v1/posts
    });

    Flight::put('/posts/1', function () {
      // Соответствует PUT /api/v1/posts
    });
  });

  Flight::group('/v2', function () {
    // Flight::get() получает переменные, а не устанавливает маршрут! См. объектный контекст ниже
    Flight::route('GET /users', function () {
      // Соответствует GET /api/v2/users
    });
  });
});
```

#### Группировка с контекстом объекта

Вы все равно можете использовать группировку маршрутов с объектом `Engine` следующим образом:

```php
$app = new \flight\Engine();
$app->group('/api/v1', function (Router $router) {
  $router->get('/users', function () {
    // Соответствует GET /api/v1/users
  });

  $router->post('/posts', function () {
    // Соответствует POST /api/v1/posts
  });
});
```

### Псевдонимы маршрутов

Вы можете назначить псевдоним маршруту, чтобы URL мог динамически генерироваться позже в вашем коде (например, для шаблона).

```php
Flight::route('/users/@id', function($id) { echo 'пользователь:'.$id; }, false, 'user_view');

// позже в коде где-то
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/users/5'
```

Это особенно полезно, если ваш URL случайно изменится. В приведенном выше примере предположим, что пользователи были перемещены в `/admin/users/@id`.
С учетом псевдонимов, вам не нужно изменять все места, где вы ссылаетесь на псевдоним, потому что псевдоним теперь вернет `/admin/users/5`, как в приведенном 
выше примере.

Псевдонимы маршрутов также работают в группах:

```php
Flight::group('/users', function() {
    Flight::route('/@id', function($id) { echo 'пользователь:'.$id; }, false, 'user_view');
});

// позже в коде где-то
Flight::getUrl('user_view', [ 'id' => 5 ]); // вернет '/users/5'
```

## <a name="extending"></a> Расширение

Flight разработан как расширяемый фреймворк. Фреймворк поставляется с набором
стандартных методов и компонентов, но позволяет вам сопоставлять ваши собственные методы,
регистрировать ваши собственные классы или даже переопределять существующие классы и методы.

### Сопоставление методов

Чтобы сопоставить ваш собственный пользовательский метод, вы используете функцию `map`:

``` php
// Сопоставьте ваш метод
Flight::map('hello', function($name){
    echo "привет $name!";
});

// Вызовите ваш пользовательский метод
Flight::hello('Bob');
```

### Регистрация классов

Чтобы зарегистрировать свой собственный класс, вы используете функцию `register`:

``` php
// Зарегистрируйте свой класс
Flight::register('user', 'User');

// Получите экземпляр вашего класса
$user = Flight::user();
```

Метод регистрации также позволяет вам передавать параметры в конструктор вашего класса. Таким образом, когда вы загружаете свой пользовательский класс, он будет предварительно инициализирован.
Вы можете определить параметры конструктора, передав дополнительный массив.
Вот пример загрузки соединения с базой данных:

``` php
// Зарегистрируйте класс с параметрами конструктора
Flight::register('db', 'PDO', array('mysql:host=localhost;dbname=test','user','pass'));

// Получите экземпляр вашего класса
// Это создаст объект с определенными параметрами
//
//     new PDO('mysql:host=localhost;dbname=test','user','pass');
//
$db = Flight::db();
```

Если вы передадите дополнительный параметр обратного вызова, он будет выполнен немедленно
после создания класса. Это позволяет вам выполнять любые процедуры настройки для вашего
нового объекта. Функция обратного вызова принимает один параметр, экземпляр нового объекта.

``` php
// Функция обратного вызова получит объект, который был создан
Flight::register('db', 'PDO', array('mysql:host=localhost;dbname=test','user','pass'),
  function($db){
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  }
);
```

По умолчанию каждый раз, когда вы загружаете свой класс, вы получите общий экземпляр.
Чтобы получить новый экземпляр класса, просто передайте `false` в качестве параметра:

``` php
// Общий экземпляр класса
$shared = Flight::db();

// Новый экземпляр класса
$new = Flight::db(false);
```

Имейте в виду, что сопоставленные методы имеют приоритет над зарегистрированными классами. Если вы
объявите оба с одинаковым именем, будет вызван только сопоставленный метод.

## <a name="overriding"></a> Переопределение

Flight позволяет вам переопределять его стандартную функциональность в соответствии с вашими собственными нуждами,
не изменяя никакого кода.

Например, когда Flight не может сопоставить URL с маршрутом, он вызывает метод `notFound`,
который отправляет общий ответ `HTTP 404`. Вы можете переопределить это поведение
с помощью метода `map`:

``` php
Flight::map('notFound', function(){
    // Отобразить пользовательскую страницу 404
    include 'errors/404.html';
});
```

Flight также позволяет вам заменять основные компоненты фреймворка.
Например, вы можете заменить класс Router по умолчанию на свой собственный пользовательский класс:

``` php
// Зарегистрируйте свой пользовательский класс
Flight::register('router', 'MyRouter');

// Когда Flight загружает экземпляр Router, он загрузит ваш класс
$myrouter = Flight::router();
```

Методы фреймворка, такие как `map` и `register`, тем не менее, не могут быть переопределены. Вы получите
ошибку, если попытаетесь это сделать.

## <a name="filtering"></a> Фильтрация

Flight позволяет вам фильтровать методы до и после их вызова. Нет
предопределенных хуков, которые нужно запоминать. Вы можете фильтровать любые методы стандартного фреймворка,
а также любые пользовательские методы, которые вы сопоставили.

Функция фильтрации выглядит так:

``` php
function(&$params, &$output) {
    // Код фильтрации
}
```

Используя переданные переменные, вы можете манипулировать входными параметрами и/или выходными данными.

Вы можете сделать так, чтобы фильтр выполнялся перед методом, сделав это:

``` php
Flight::before('start', function(&$params, &$output){
    // Сделать что-то
});
```

Вы можете сделать так, чтобы фильтр выполнялся после метода, сделав это:

``` php
Flight::after('start', function(&$params, &$output){
    // Сделать что-то
});
```

Вы можете добавлять столько фильтров, сколько хотите, к любому методу. Они будут вызываться в
порядке, в котором они объявлены.

Вот пример процесса фильтрации:

``` php
// Сопоставьте пользовательский метод
Flight::map('hello', function($name){
    return "Привет, $name!";
});

// Добавьте фильтр до
Flight::before('hello', function(&$params, &$output){
    // Манипулировать параметром
    $params[0] = 'Фред';
});

// Добавьте фильтр после
Flight::after('hello', function(&$params, &$output){
    // Манипулировать выводом
    $output .= " Хорошего дня!";
});

// Вызовите пользовательский метод
echo Flight::hello('Bob');
```

Это должно отобразить:

``` html
Привет Фред! Хорошего дня!
```

Если вы определили несколько фильтров, вы можете прервать цепочку, вернув `false`
в любой из ваших функций фильтра:

``` php
Flight::before('start', function(&$params, &$output){
    echo 'один';
});

Flight::before('start', function(&$params, &$output){
    echo 'два';

    // Это закончит цепочку
    return false;
});

// Это не будет вызвано
Flight::before('start', function(&$params, &$output){
    echo 'три';
});
```

Обратите внимание, что основные методы, такие как `map` и `register`, не могут быть отфильтрованы, потому что они
вызываются непосредственно, а не динамически.

## <a name="variables"></a> Переменные

Flight позволяет вам сохранять переменные, чтобы их можно было использовать в любом месте вашего приложения.

``` php
// Сохраните вашу переменную
Flight::set('id', 123);

// В другом месте вашего приложения
$id = Flight::get('id');
```
Чтобы проверить, была ли установлена переменная, вы можете сделать:

``` php
if (Flight::has('id')) {
     // Сделать что-то
}
```

Вы можете очистить переменную так:

``` php
// Очищает переменную id
Flight::clear('id');

// Очищает все переменные
Flight::clear();
```

Flight также использует переменные для конфигурационных целей.

``` php
Flight::set('flight.log_errors', true);
```

## <a name="views"></a> Представления

Flight предоставляет базовую функциональность для шаблонирования по умолчанию. Чтобы отобразить
шаблон представления, вызовите метод `render` с именем файла шаблона и опциональными
данными шаблона:

``` php
Flight::render('hello.php', array('name' => 'Bob'));
```

Данные шаблона, которые вы передаете, автоматически внедряются в шаблон и могут
быть ссылкой как на локальную переменную. Файлы шаблонов - это просто файлы PHP. Если
содержимое файла шаблона `hello.php`:

``` php
Привет, '<?php echo $name; ?>'!
```

Вывод будет:

``` html
Привет, Bob!
```

Вы также можете вручную установить переменные представления, используя метод set:

``` php
Flight::view()->set('name', 'Bob');
```

Переменная `name` теперь доступна во всех ваших представлениях. Таким образом, вы можете просто сделать:

``` php
Flight::render('hello');
```

Обратите внимание, что при указании имени шаблона в методе render, вы можете
опустить расширение `.php`.

По умолчанию Flight будет искать каталог `views` для файлов шаблонов. Вы можете
установить альтернативный путь для ваших шаблонов, установив следующую конфигурацию:

``` php
Flight::set('flight.views.path', '/path/to/views');
```

### Макеты

Общепринято для веб-сайтов иметь один файл шаблона макета с взаимозаменяемым 
контентом. Чтобы отобразить контент, который будет использоваться в макете, вы можете передать опциональный
параметр в метод `render`.

``` php
Flight::render('header', array('heading' => 'Привет'), 'header_content');
Flight::render('body', array('body' => 'Мир'), 'body_content');
```

Ваше представление будет затем иметь сохраненные переменные `header_content` и `body_content`.
Затем вы можете отобразить ваш макет, сделав это:

``` php
Flight::render('layout', array('title' => 'Главная страница'));
```

Если файлы шаблонов выглядят так:

`header.php`:

``` php
<h1><?php echo $heading; ?></h1>
```

`body.php`:

``` php
<div><?php echo $body; ?></div>
```

`layout.php`:

``` php
<html>
<head>
<title><?php echo $title; ?></title>
</head>
<body>
<?php echo $header_content; ?>
<?php echo $body_content; ?>
</body>
</html>
```

Вывод будет:

``` html
<html>
<head>
<title>Главная страница</title>
</head>
<body>
<h1>Привет</h1>
<div>Мир</div>
</body>
</html>
```

### Пользовательские представления

Flight позволяет вам менять стандартный движок представлений, просто зарегистрировав
ваш собственный класс представления. Вот как вы бы использовали [Smarty](http://www.smarty.net/)
движок шаблонов для ваших представлений:

``` php
// Загрузите библиотеку Smarty
require './Smarty/libs/Smarty.class.php';

// Зарегистрируйте Smarty в качестве класса представлений
// Также передайте функцию обратного вызова для настройки Smarty при загрузке
Flight::register('view', 'Smarty', array(), function($smarty){
    $smarty->template_dir = './templates/';
    $smarty->compile_dir = './templates_c/';
    $smarty->config_dir = './config/';
    $smarty->cache_dir = './cache/';
});

// Назначьте данные шаблона
Flight::view()->assign('name', 'Bob');

// Отобразите шаблон
Flight::view()->display('hello.tpl');
```

Для полноты картины вам также следует переопределить стандартный метод рендеринга Flight:

``` php
Flight::map('render', function($template, $data){
    Flight::view()->assign($data);
    Flight::view()->display($template);
});
```

## <a name="errorhandling"></a> Обработка ошибок

### Ошибки и Исключения

Все ошибки и исключения перехватываются Flight и передаются в метод `error`.
Стандартное поведение - отправить общий ответ `HTTP 500 Внутренняя ошибка сервера`
с некоторой информацией об ошибке.

Вы можете переопределить это поведение в соответствии с вашими нуждами:

``` php
Flight::map('error', function(Exception $ex){
    // Обработать ошибку
    echo $ex->getTraceAsString();
});
```

По умолчанию ошибки не записываются в веб-сервер. Вы можете включить это, изменив конфигурацию:

``` php
Flight::set('flight.log_errors', true);
```

### Не найдено

Когда URL не может быть найден, Flight вызывает метод `notFound`. Стандартное
поведение - отправить ответ `HTTP 404 Не найдено` с простым сообщением.

Вы можете переопределить это поведение в соответствии с вашими нуждами:

``` php
Flight::map('notFound', function(){
    // Обработать не найдено
});
```

## <a name="redirects"></a> Перенаправления

Вы можете перенаправить текущий запрос, используя метод `redirect` и передав
ему новый URL:

``` php
Flight::redirect('/new/location');
```

По умолчанию Flight отправляет код состояния HTTP 303. Вы также можете установить
пользовательский код:

``` php
Flight::redirect('/new/location', 401);
```

## <a name="requests"></a> Запросы

Flight инкапсулирует HTTP-запрос в одном объекте, который можно получить, сделав:

``` php
$request = Flight::request();
```

Объект запроса предоставляет следующие свойства:

``` html
url - Запрашиваемый URL
base - Родительский подпапка URL
method - Метод запроса (GET, POST, PUT, DELETE)
referrer - URL реферера
ip - IP-адрес клиента
ajax - Является ли запрос AJAX-запросом
scheme - Протокол сервера (http, https)
user_agent - Информация о браузере
type - Тип контента
length - Длина контента
query - Параметры строки запроса
data - Данные Post или JSON-данные
cookies - Данные cookie
files - Загруженные файлы
secure - Является ли соединение безопасным
accept - HTTP параметры accept
proxy_ip - IP-адрес прокси клиента
```

Вы можете получить доступ к свойствам `query`, `data`, `cookies` и `files`
как к массивам или объектам.

Итак, чтобы получить параметр строки запроса, вы можете сделать:

``` php
$id = Flight::request()->query['id'];
```

Или вы можете сделать:

``` php
$id = Flight::request()->query->id;
```

### НЕПРЕОБРАЗОВАННОЕ тело запроса

Чтобы получить необработанное тело HTTP-запроса, например, когда дело касается запросов PUT, вы можете сделать:

``` php
$body = Flight::request()->getBody();
```

### JSON Входные данные

Если вы отправляете запрос с типом `application/json` и данными `{"id": 123}`, он будет доступен
из свойства `data`:

``` php
$id = Flight::request()->data->id;
```

## <a name="stopping"></a> Остановить

Вы можете остановить фреймворк в любой момент, вызвав метод `halt`:

``` php
Flight::halt();
```

Вы также можете указать необязательный код статуса `HTTP` и сообщение:

``` php
Flight::halt(200, 'Сейчас вернусь...');
```

Вызов `halt` отменит весь контент ответа до этого момента. Если вы хотите остановить
фреймворк и вывести текущий ответ, используйте метод `stop`:

``` php
Flight::stop();
```

## <a name="httpcaching"></a> HTTP Кэширование

Flight предоставляет встроенную поддержку кэширования на уровне HTTP. Если кэшируемое условие
выполняется, Flight вернет ответ HTTP `304 Не изменялся`. В следующий раз, когда клиент 
запросит тот же ресурс, ему будет предложено использовать свою локально
кэшированную версию.

### Последнее изменение

Вы можете использовать метод `lastModified` и передать в него временную метку UNIX, чтобы установить дату
и время последнего изменения страницы. Клиент будет продолжать использовать свой кэш, пока
значение последнего изменения не будет изменено.

``` php
Flight::route('/news', function(){
    Flight::lastModified(1234567890);
    echo 'Этот контент будет кэшироваться.';
});
```

### ETag

Кэширование `ETag` похоже на `Последнее изменение`, за исключением того, что вы можете указать любой id, который
вы хотите для ресурса:

``` php
Flight::route('/news', function(){
    Flight::etag('my-unique-id');
    echo 'Этот контент будет кэшироваться.';
});
```

Имейте в виду, что вызов либо `lastModified`, либо `etag` установит и проверит
значение кэша. Если значение кэша остается таким же между запросами, Flight немедленно
отправит ответ `HTTP 304` и прекратит обработку.

## <a name="json"></a> JSON

Flight поддерживает отправку ответов в формате JSON и JSONP. Чтобы отправить ответ в формате JSON, вы
передаете некоторые данные для кодирования в JSON:

``` php
Flight::json(array('id' => 123));
```

Для запросов JSONP вы можете опционально передать имя параметра запроса, который вы
используете для определения вашей функции обратного вызова:

``` php
Flight::jsonp(array('id' => 123), 'q');
```

Таким образом, при выполнении GET-запроса с использованием `?q=my_func` вы должны получить вывод:

``` json
my_func({"id":123});
```

Если вы не передадите имя параметра запроса, по умолчанию оно будет `jsonp`.

## <a name="configuration"></a> Конфигурация

Вы можете настраивать определенные поведения Flight, устанавливая значения конфигурации
с помощью метода `set`.

``` php
Flight::set('flight.log_errors', true);
```

Ниже приведен список всех доступных настроек конфигурации:

``` html 
flight.base_url - Переопределить основной URL запроса. (по умолчанию: null)
flight.case_sensitive - Чувствительное к регистру сопоставление для URL. (по умолчанию: false)
flight.handle_errors - Позволить Flight обрабатывать все ошибки внутри. (по умолчанию: true)
flight.log_errors - Записывать ошибки в файл журнала ошибок веб-сервера. (по умолчанию: false)
flight.views.path - Директория, содержащая файлы шаблонов представлений. (по умолчанию: ./views)
flight.views.extension - Расширение файла шаблона представления. (по умолчанию: .php)
```

## <a name="frameworkmethods"></a> Методы фреймворка

Flight спроектирован так, чтобы его было легко использовать и понимать. Ниже приводится полный
набор методов для фреймворка. Он состоит из основных методов, которые являются обычными
статическими методами, и расширяемых методов, которые являются сопоставленными методами, которые можно фильтровать
или переопределять.

### Основные методы

```php
Flight::map(string $name, callable $callback, bool $pass_route = false) // Создает пользовательский метод фреймворка.
Flight::register(string $name, string $class, array $params = [], ?callable $callback = null) // Регистрирует класс для метода фреймворка.
Flight::before(string $name, callable $callback) // Добавляет фильтр перед методом фреймворка.
Flight::after(string $name, callable $callback) // Добавляет фильтр после метода фреймворка.
Flight::path(string $path) // Добавляет путь для автозагрузки классов.
Flight::get(string $key) // Получает переменную.
Flight::set(string $key, mixed $value) // Устанавливает переменную.
Flight::has(string $key) // Проверяет, установлена ли переменная.
Flight::clear(array|string $key = []) // Очищает переменную.
Flight::init() // Инициализирует фреймворк с его стандартными настройками.
Flight::app() // Получает экземпляр объекта приложения
```

### Расширяемые методы

```php
Flight::start() // Запускает фреймворк.
Flight::stop() // Останавливает фреймворк и отправляет ответ.
Flight::halt(int $code = 200, string $message = '') // Остановите фреймворк с необязательным кодом состояния и сообщением.
Flight::route(string $pattern, callable $callback, bool $pass_route = false) // Сопоставляет шаблон URL с обратным вызовом.
Flight::group(string $pattern, callable $callback) // Создает группировку для URL, шаблон должен быть строкой.
Flight::redirect(string $url, int $code) // Перенаправляет на другой URL.
Flight::render(string $file, array $data, ?string $key = null) // Отображает файл шаблона.
Flight::error(Throwable $error) // Отправляет ответ HTTP 500.
Flight::notFound() // Отправляет ответ HTTP 404.
Flight::etag(string $id, string $type = 'string') // Выполняет кэширование HTTP ETag.
Flight::lastModified(int $time) // Выполняет кэширование HTTP последнего изменения.
Flight::json(mixed $data, int $code = 200, bool $encode = true, string $charset = 'utf8', int $option) // Отправляет ответ JSON.
Flight::jsonp(mixed $data, string $param = 'jsonp', int $code = 200, bool $encode = true, string $charset = 'utf8', int $option) // Отправляет ответ JSONP.
```

Любые пользовательские методы, добавленные с помощью `map` и `register`, также могут быть отфильтрованы.


## <a name="frameworkinstance"></a> Экземпляр фреймворка

Вместо того чтобы запускать Flight как глобальный статический класс, вы можете при желании запустить его
как экземпляр объекта.

``` php
require 'flight/autoload.php';

use flight\Engine;

$app = new Engine();

$app->route('/', function(){
    echo 'привет мир!';
});

$app->start();
```

Таким образом, вместо вызова статического метода вы будете вызывать метод экземпляра с
тем же именем на объекте Engine.