# Миграция на v3

Обратная совместимость в целом была сохранена, но есть некоторые изменения, о которых вам следует знать при переходе с v2 на v3.

## Поведение буферизации вывода (3.5.0)

[Буферизация вывода](https://stackoverflow.com/questions/2832010/what-is-output-buffering-in-php) - это процесс, при котором вывод, 
сгенерированный сценарием PHP, хранится в буфере (внутри PHP) перед отправкой клиенту. Это позволяет вам изменять вывод перед его 
отправкой клиенту.

В приложении MVC Контроллер является "менеджером" и управляет тем, что делает представление. Генерация вывода за пределами 
контроллера (или в случае Flight иногда анонимной функции) нарушает шаблон MVC. Это изменение призвано больше соответствовать 
шаблону MVC и сделать фреймворк более предсказуемым и легким в использовании.

В v2 буферизация вывода обрабатывалась таким образом, что не всегда закрывался собственный буфер вывода, что затрудняло 
[unit тестирование](https://github.com/flightphp/core/pull/545/files#diff-eb93da0a3473574fba94c3c4160ce68e20028e30b267875ab0792ade0b0539a0R42) 
и [потоковую передачу](https://github.com/flightphp/core/issues/413). Для большинства пользователей это изменение на самом деле 
может вас не затронуть. Однако, если вы выводите содержимое вне вызываемых функций и контроллеров (например, в хуке), вам, скорее 
всего, придется столкнуться с проблемами. Вывод содержимого в хуках и до фактического выполнения фреймворка мог работать в прошлом, 
но это не сработает в будущем.

### Где у вас могут возникнуть проблемы
```php
// index.php
require 'vendor/autoload.php';

// просто пример
define('START_TIME', microtime(true));

function hello() {
	echo 'Привет, мир';
}

Flight::map('hello', 'hello');
Flight::after('hello', function(){
	// это на самом деле будет хорошо
	echo '<p>Эта фраза Привет, мир была предоставлена буквой "П"</p>';
});

Flight::before('start', function(){
	// такие вещи вызовут ошибку
	echo '<html><head><title>Моя страница</title></head><body>';
});

Flight::route('/', function(){
	// это на самом деле в порядке
	echo 'Привет, мир';

	// Это тоже должно быть в порядке
	Flight::hello();
});

Flight::after('start', function(){
	// это вызовет ошибку
	echo '<div>Ваша страница загрузилась за '.(microtime(true) - START_TIME).' секунд</div></body></html>';
});
```

### Включение поведения рендеринга v2

Можно ли сохранить ваш старый код без переписывания, чтобы он работал с v3? Да, вы можете! Вы можете включить поведение 
рендеринга v2, установив параметр конфигурации `flight.v2.output_buffering` в значение `true`. Это позволит вам продолжать 
использовать старое поведение рендеринга, но рекомендуется исправить его на будущее. В v4 фреймворка это будет удалено.

```php
// index.php
require 'vendor/autoload.php';

Flight::set('flight.v2.output_buffering', true);

Flight::before('start', function(){
	// Теперь это будет в порядке
	echo '<html><head><title>Моя страница</title></head><body>';
});

// еще код 
```

## Изменения Диспетчера (3.7.0)

Если вы напрямую вызывали статические методы для `Dispatcher`, такие как `Dispatcher::invokeMethod()`, `Dispatcher::execute()`, и т.д., 
вам потребуется обновить ваш код, чтобы не вызывать эти методы напрямую. `Dispatcher` был преобразован в более объектно-ориентированный 
для удобства использования контейнеров внедрения зависимостей. Если вам нужно вызвать метод аналогично тому, как делал Диспетчер, 
вы можете вручную использовать что-то вроде `$result = $class->$method(...$params);` или `call_user_func_array()` вместо этого.

## Изменения `halt()` `stop()` `redirect()` и `error()` (3.10.0)

Поведение по умолчанию до версии 3.10.0 заключалось в очистке как заголовков, так и тела ответа. Это было изменено на очистку 
только тела ответа. Если вам нужно очистить также заголовки, вы можете использовать `Flight::response()->clear()`.