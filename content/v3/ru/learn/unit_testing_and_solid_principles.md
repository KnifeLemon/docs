> _Эта статья была originally опубликована на [Airpair](https://web.archive.org/web/20220204014708/https://www.airpair.com/php/posts/best-practices-for-modern-php-development#5-unit-testing) в 2015 году. Вся заслуга принадлежит Airpair и Brian Fenton, который originally написал эту статью, хотя веб-сайт более не доступен, и статья существует только в [Wayback Machine](https://web.archive.org/web/20220204014708/https://www.airpair.com/php/posts/best-practices-for-modern-php-development#5-unit-testing). Эта статья была добавлена на сайт для обучения и образовательных целей для сообщества PHP в целом._

1 Настройка и конфигурация
-------------------------

### 1.1 Поддерживайте актуальность

Давайте обозначим это с самого начала - удручающе малое число установок PHP в реальном мире являются актуальными или поддерживаются в актуальном состоянии. Будь то из-за ограничений общего хостинга, стандартных настроек, которые никто не думает изменить, или отсутствия времени/бюджета на тестирование обновлений, скромные бинарники PHP склонны отставать. Таким образом, одна из четких лучших практик, которая нуждается в большем акценте, - всегда использовать актуальную версию PHP (5.6.x на момент написания этой статьи). Кроме того, важно планировать регулярные обновления как самого PHP, так и любых расширений или библиотек поставщиков, которые вы используете. Обновления предоставляют новые функции языка, улучшенную скорость, меньшее использование памяти и обновления безопасности. Чем чаще вы обновляетесь, тем менее болезненным становится процесс.

### 1.2 Установите разумные настройки по умолчанию

PHP делает приличную работу по установке хороших настроек по умолчанию в файлах _php.ini.development_ и _php.ini.production_, но мы можем сделать лучше. Во-первых, они не устанавливают дату/временную зону для нас. Это имеет смысл с точки зрения распространения, но без нее PHP будет генерировать ошибку E_WARNING каждый раз, когда мы вызываем функцию, связанную с датой/временем. Вот некоторые рекомендуемые настройки:

*   date.timezone - выберите из [списка поддерживаемых временных зон](http://php.net/manual/en/timezones.php)
*   session.save_path - если мы используем файлы для сессий и не какой-либо другой обработчик сохранения, установите это вне _/tmp_. Оставление этого как _/tmp_ может быть рискованным в среде общего хостинга, поскольку _/tmp_ обычно имеет широкие разрешения. Даже с установленным битом sticky, любой, у кого есть доступ к перечислению содержимого этой директории, может узнать все ваши активные идентификаторы сессий.
*   session.cookie_secure - очевидно, включите это, если вы обслуживаете код PHP по HTTPS.
*   session.cookie_httponly - установите это, чтобы предотвратить доступ к cookie сессий PHP через JavaScript
*   Ещё... используйте инструмент вроде [iniscan](https://github.com/psecio/iniscan), чтобы проверить вашу конфигурацию на наличие распространенных уязвимостей

### 1.3 Расширения

Также хорошей идеей является отключение (или хотя бы не включение) расширений, которые вы не будете использовать, как драйверы баз данных. Чтобы увидеть, что включено, запустите команду `phpinfo()` или перейдите в командную строку и запустите это.

```bash
$ php -i
``` 

Информация та же, но phpinfo() добавляет HTML-форматирование. Версия CLI проще для перенаправления в grep для поиска конкретной информации. Прим.

```bash
$ php -i | grep error_log
```

Один нюанс этого метода: возможно, что разные настройки PHP применяются к веб-ориентированной версии и версии CLI.

2 Используйте Composer
--------------

Это может показаться сюрпризом, но одна из лучших практик для написания современного PHP - писать меньше кода. Хотя правда, что один из лучших способов освоить программирование - делать это, существует множество уже решенных проблем в пространстве PHP, таких как маршрутизация, базовые библиотеки проверки ввода, преобразование единиц, слои абстракции баз данных и т.д... Просто перейдите на [Packagist](https://www.packagist.org/) и посмотрите. Вы, вероятно, обнаружите, что значительная часть проблемы, которую вы пытаетесь решить, уже написана и протестирована.

Хотя tempting писать весь код самому (и нет ничего плохого в написании собственного фреймворка или библиотеки как опыта обучения) вы должны бороться с этими чувствами "Не Изобретено Здесь" и сэкономить себе кучу времени и головной боли. Следуйте доктрине PIE вместо этого - Proudly Invented Elsewhere. Кроме того, если вы решите написать свое собственное что-то, не выпускайте это, если оно делает что-то значительно другое или лучше, чем существующие предложения.

[Composer](https://www.getcomposer.org/) - это менеджер пакетов для PHP, подобный pip в Python, gem в Ruby и npm в Node. Он позволяет определить JSON-файл, который перечисляет зависимости вашего кода, и он попытается разрешить эти требования, скачивая и устанавливая необходимый код.

### 2.1 Установка Composer

Мы предполагаем, что это локальный проект, так что давайте установим экземпляр Composer только для текущего проекта. Перейдите в директорию проекта и запустите это:
```bash
$ curl -sS https://getcomposer.org/installer | php
```

Помните, что перенаправление любого скачивания напрямую в интерпретатор скрипта (sh, ruby, php и т.д.) - это риск безопасности, так что прочитайте код установки и убедитесь, что вы комфортны с ним, прежде чем запускать любую такую команду.

Для удобства (если вы предпочитаете набирать `composer install` вместо `php composer.phar install`), вы можете использовать эту команду, чтобы установить единственную копию composer глобально:

```bash
$ mv composer.phar /usr/local/bin/composer
$ chmod +x composer
```

Вам может потребоваться запустить эти с `sudo` в зависимости от ваших прав доступа к файлам.

### 2.2 Использование Composer

У Composer две основные категории зависимостей, которые он может управлять: "require" и "require-dev". Зависимости, перечисленные как "require", устанавливаются везде, но зависимости "require-dev" устанавливаются только при конкретном запросе. Обычно это инструменты для активной разработки, такие как [PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer). Строка ниже показывает пример, как установить [Guzzle](http://docs.guzzlephp.org/en/latest/), популярную HTTP-библиотеку.

```bash
$ php composer.phar require guzzle/guzzle
```

Чтобы установить инструмент только для целей разработки, добавьте флаг `--dev`:

```bash
$ php composer.phar require --dev 'sebastian/phpcpd'
```

Это устанавливает [PHP Copy-Paste Detector](https://github.com/sebastianbergmann/phpcpd), другой инструмент качества кода, как зависимость только для разработки.

### 2.3 Install vs update

Когда мы впервые запускаем `composer install`, он установит любые библиотеки и их зависимости, которые нам нужны, на основе файла _composer.json_. Когда это сделано, composer создает файл блокировки, предсказуемо называемый _composer.lock_. Этот файл содержит список зависимостей, которые composer нашел для нас, и их точные версии, с хешами. Затем любой следующий раз, когда мы запускаем `composer install`, он посмотрит в файл блокировки и установит именно эти версии.

`composer update` - это немного другое существо. Он игнорирует файл _composer.lock_ (если он присутствует) и попытается найти самые актуальные версии каждой из зависимостей, которые все еще удовлетворяют ограничениям в _composer.json_. Затем он запишет новый файл _composer.lock_, когда закончит.

### 2.4 Автозагрузка

Как `composer install`, так и `composer update` сгенерируют [автозагрузчик](https://getcomposer.org/doc/04-schema.md#autoload) для нас, который говорит PHP, где найти все необходимые файлы для использования библиотек, которые мы только что установили. Чтобы использовать его, просто добавьте эту строку (обычно в файл bootstrap, который выполняется на каждый запрос):
```php
require 'vendor/autoload.php';
```

3 Следуйте хорошим принципам дизайна
-------------------------------

### 3.1 SOLID

SOLID - это мнемоника, чтобы напомнить нам о пяти ключевых принципах хорошего объектно-ориентированного дизайна программного обеспечения.

#### 3.1.1 S - Принцип единственной ответственности

Это гласит, что классы должны иметь только одну ответственность, или, иными словами, у них должен быть только один повод для изменения. Это хорошо сочетается с философией Unix множества малых инструментов, делающих одну вещь хорошо. Классы, которые делают только одну вещь, гораздо легче тестировать и отлаживать, и они менее склонны удивлять вас. Вы не хотите, чтобы вызов метода в классе Validator обновлял записи в БД. Вот пример нарушения SRP, который вы часто видите в приложении на основе [шаблона ActiveRecord](http://en.wikipedia.org/wiki/Active_record_pattern).

```php
class Person extends Model
{
    public $name;
    public $birthDate;
    protected $preferences;
    public function getPreferences() {}
    public function save() {}
}
```
    

Итак, это довольно базовая [модель сущности](http://lostechies.com/jimmybogard/2008/05/21/entities-value-objects-aggregates-and-roots/). Но одна из этих вещей не подходит сюда. Единственная ответственность модели сущности должна заключаться в поведении, связанном с сущностью, которую она представляет, она не должна быть responsible за сохранение себя.

```php
class Person extends Model
{
    public $name;
    public $birthDate;
    protected $preferences;
    public function getPreferences() {}
}
class DataStore
{
    public function save(Model $model) {}
}
```

Это лучше. Модель Person вернулась к тому, чтобы делать только одну вещь, а поведение сохранения было перенесено в объект сохранения. Обратите внимание, что я указал тип только на Model, а не на Person. Мы вернемся к этому, когда дойдем до частей L и D SOLID.

#### 3.1.2 O - Принцип открытости/замкнутости

Есть потрясающий тест для этого, который довольно точно суммирует, о чем этот принцип: подумайте о функции для реализации, вероятно, самой недавней, над которой вы работали или работаете. Можете ли вы реализовать эту функцию в существующей кодовой базе ТОЛЬКО путем добавления новых классов и без изменения каких-либо существующих классов в вашей системе? Ваша конфигурация и код wiring получают некоторое послабление, но в большинстве систем это удивительно сложно. Вам приходится полагаться на полиморфный dispatch, и большинство кодовых баз просто не настроены на это. Если вас это интересует, есть хороший Google talk на YouTube о [полиморфизме и написании кода без If](https://www.youtube.com/watch?v=4F72VULWFvc), который углубляется в это дальше. В качестве бонуса, доклад делает [Miško Hevery](http://misko.hevery.com/), которого многие знают как создателя [AngularJs](https://angularjs.org/).

#### 3.1.3 L - Принцип подстановки Лисков

Этот принцип назван в честь [Barbara Liskov](http://en.wikipedia.org/wiki/Barbara_Liskov) и сформулирован ниже:

> "Объекты в программе должны быть заменяемыми экземплярами своих подтипов без изменения корректности этой программы."

Это звучит хорошо, но это более четко иллюстрируется на примере.

```php
abstract class Shape
{
    public function getHeight();
    public function setHeight($height);
    public function getLength();
    public function setLength($length);
}
```   

Это будет представлять наш базовый четырехсторонний shape. Ничего особенного здесь.

```php
class Square extends Shape
{
    protected $size;
    public function getHeight() {
        return $this->size;
    }
    public function setHeight($height) {
        $this->size = $height;
    }
    public function getLength() {
        return $this->size;
    }
    public function setLength($length) {
        $this->size = $length;
    }
}
```

Вот наш первый shape, квадрат. Довольно простой shape, правда? Вы можете предположить, что есть конструктор, где мы устанавливаем размеры, но вы видите здесь из этой реализации, что длина и высота всегда будут одинаковыми. Квадраты такие.

```php
class Rectangle extends Shape
{
    protected $height;
    protected $length;
    public function getHeight() {
        return $this->height;
    }
    public function setHeight($height) {
        $this->height = $height;
    }
    public function getLength() {
        return $this->length;
    }
    public function setLength($length) {
        $this->length = $length;
    }
}
```

Итак, вот другой shape. Все еще имеет те же сигнатуры методов, это все еще четырехсторонний shape, но что, если мы начнем пытаться использовать их взаимозаменяемо? Теперь вдруг, если мы изменим высоту нашего Shape, мы больше не можем предположить, что длина нашего shape совпадет. Мы нарушили контракт, который имели с пользователем, когда дали им наш Square shape.

Это классический пример нарушения LSP, и нам нужен такой тип принципа, чтобы максимально использовать систему типов. Даже [duck typing](http://en.wikipedia.org/wiki/Duck_typing) не скажет нам, если базовое поведение отличается, и поскольку мы не можем знать это без того, чтобы увидеть, как оно ломается, лучше убедиться, что оно не отличается изначально.

#### 3.1.3 I - Принцип сегрегаации интерфейсов

Этот принцип говорит отдавать предпочтение многим малым, тонким интерфейсам по сравнению с одним большим. Интерфейсы должны основываться на поведении, а не на "это один из этих классов". Подумайте об интерфейсах, которые поставляются с PHP. Traversable, Countable, Serializable, вещи вроде того. Они рекламируют возможности, которыми обладает объект, а не то, от чего он наследует. Так что держите свои интерфейсы маленькими. Вы не хотите, чтобы интерфейс имел 30 методов, 3 - гораздо лучшая цель.

#### 3.1.4 D - Принцип инверсии зависимостей

Вы, вероятно, слышали об этом в других местах, где говорили о [Dependency Injection](http://en.wikipedia.org/wiki/Dependency_injection), но Dependency Inversion и Dependency Injection - не совсем одно и то же. Dependency inversion - это в основном способ сказать, что вы должны зависеть от абстракций в вашей системе, а не от ее деталей. Что это значит для вас в повседневной жизни?

> Не используйте mysqli_query() напрямую по всему коду, используйте что-то вроде DataStore->query() вместо.

Ядро этого принципа - это абстракции. Это больше о том, чтобы сказать "используйте адаптер базы данных" вместо зависимости от прямых вызовов, как mysqli_query. Если вы напрямую используете mysqli_query в половине своих классов, то вы привязываете все напрямую к вашей базе данных. Ничего против MySQL, но если вы используете mysqli_query, этот тип низкоуровневых деталей должен быть скрыт в одном месте, а затем эта функциональность должна быть раскрыта через общий обертку.

Теперь я знаю, что это своего рода избитый пример, если вы подумаете об этом, потому что количество раз, когда вы фактически полностью измените движок базы данных после ввода продукта в производство, очень, очень мало. Я выбрал это, потому что подумал, что люди будут знакомы с идеей из своего собственного кода. Кроме того, даже если у вас есть база данных, с которой вы знаете, что останетесь, этот абстрактный объект-обертка позволяет вам исправлять ошибки, изменять поведение или реализовывать функции, которые вы желаете, чтобы ваша выбранная база данных имела. Это также делает unit testing возможным, где низкоуровневые вызовы не сделали бы.

4 Объектные упражнения
---------------------

Это не полный погружение в эти принципы, но первые два легко запомнить, предоставляют хорошую ценность и могут быть немедленно применены к практически любой кодовой базе.

### 4.1 Не более одного уровня отступа на метод

Это полезный способ думать о разложении методов на меньшие фрагменты, оставляя код, который чище и более самодокументирующийся. Чем больше уровней отступа у вас есть, тем больше метод делает и тем больше состояния вы должны отслеживать в своей голове, пока работаете с ним.

Сразу я знаю, люди будут возражать против этого, но это просто рекомендация/эвристика, а не жесткое правило. Я не ожидаю, что кто-то будет применять правила PHP_CodeSniffer для этого (хотя [люди делали](https://github.com/object-calisthenics/phpcs-calisthenics-rules)).

Давайте пройдемся по быстрому образцу того, как это может выглядеть:

```php
public function transformToCsv($data)
{
    $csvLines = array();
    $csvLines[] = implode(',', array_keys($data[0]));
    foreach ($data as $row) {
        if (!$row) {
            continue;
        }
        $csvLines[] = implode(',', $row);
    }
    return $csvLines;
}
```

Хотя это не ужасный код (он технически правильный, тестируемый и т.д.), мы можем сделать гораздо больше, чтобы сделать это ясным. Как мы можем уменьшить уровни вложенности здесь?

Мы знаем, что нужно значительно упростить содержимое цикла foreach (или удалить его полностью), так давайте начнем с этого.

```php
if (!$row) {
    continue;
}
```   

Эта первая часть проста. Это просто игнорирует пустые строки. Мы можем сократить весь этот процесс, используя встроенную функцию PHP до того, как добраться до цикла.

```php
$data = array_filter($data);
foreach ($data as $row) {
    $csvLines[] = implode(',', $row);
}
```

Теперь у нас один уровень вложенности. Но, looking at this, все, что мы делаем, - это применяем функцию к каждому элементу массива. Нам даже не нужен цикл foreach для этого.

```php
$data = array_filter($data);
$csvLines = array_map(function($row) {
    return implode(',', $row);
}, $data);
```

Теперь у нас нет вложенности вообще, и код, вероятно, будет быстрее, поскольку мы делаем весь цикл с нативными C-функциями вместо PHP. Нам приходится заниматься некоторым трюком, чтобы передать запятую в `implode`, так что вы можете утверждать, что остановка на предыдущем шаге гораздо понятнее.

### 4.2 Старайтесь не использовать `else`

Это действительно касается двух основных идей. Первая - несколько операторов return из метода. Если у вас достаточно информации, чтобы принять решение об результате метода, просто примите это решение и вернитесь. Вторая - идея, известная как [Guard Clauses](http://c2.com/cgi/wiki?GuardClause). Это в основном проверки валидации, объединенные с ранними возвратами, обычно в начале метода. Позвольте мне показать, что я имею в виду.

```php
public function addThreeInts($first, $second, $third) {
    if (is_int($first)) {
        if (is_int($second)) {
            if (is_int($third)) {
                $sum = $first + $second + $third;
            } else {
                return null;
            }
        } else {
            return null;
        }
    } else {
        return null;
    }
    return $sum;
}
```

Итак, это довольно прямолинейно, оно добавляет 3 целых числа и возвращает результат или `null`, если любой из параметров не является целым. Игнорируя тот факт, что мы могли объединить все эти проверки в одну строку с операторами AND, я думаю, вы можете увидеть, как вложенная структура if/else делает код сложнее для следования. Теперь посмотрите на этот пример вместо.

```php
public function addThreeInts($first, $second, $third) {
    if (!is_int($first)) {
        return null;
    }
    if (!is_int($second)) {
        return null;
    }
    if (!is_int($third)) {
        return null;
    }
    return $first + $second + $third;
}
```   

Для меня этот пример гораздо легче следовать. Здесь мы используем guard clauses, чтобы проверить наши начальные утверждения о параметрах, которые мы передаем, и немедленно выйти из метода, если они не проходят. Мы также больше не имеем промежуточную переменную для отслеживания суммы на протяжении всего метода. В этом случае мы убедились, что уже находимся на happy path, и можем просто делать то, для чего пришли. Опять же, мы могли бы сделать все эти проверки в одном `if`, но принцип должен быть ясен.

5 Unit testing
--------------

Unit testing - это практика написания малых тестов, которые проверяют поведение в вашем коде. Они почти всегда пишутся на том же языке, что и код (в данном случае PHP), и предназначены для того, чтобы быть достаточно быстрыми, чтобы запускаться в любое время. Они чрезвычайно ценны как инструмент для улучшения вашего кода. Помимо очевидных преимуществ обеспечения того, что ваш код делает то, что вы думаете, unit testing может предоставить очень полезную обратную связь дизайна. Если кусок кода трудно протестировать, это часто подчеркивает проблемы дизайна. Они также дают вам страховочную сеть против регрессий, и это позволяет вам рефакторить гораздо чаще и эволюционировать ваш код к чищему дизайну.

### 5.1 Инструменты

Существует несколько инструментов unit testing в PHP, но далеко не самый распространенный - [PHPUnit](https://phpunit.de/). Вы можете установить его, скачав [PHAR](http://php.net/manual/en/intro.phar.php) файл [непосредственно](https://phar.phpunit.de/phpunit.phar), или установить с composer. Поскольку мы используем composer для всего остального, мы покажем этот метод. Кроме того, поскольку PHPUnit, вероятно, не будет развернут в production, мы можем установить его как зависимость dev с помощью следующей команды:

```bash
composer require --dev phpunit/phpunit
```

### 5.2 Тесты - это спецификация

Самая важная роль unit тестов в вашем коде - предоставить исполняемую спецификацию того, что код предполагается делать. Даже если код теста неверен или код имеет ошибки, знание того, что система _должна_ делать, бесценно.

### 5.3 Пишите тесты сначала

Если у вас была возможность увидеть набор тестов, написанных перед кодом и один, написанный после завершения кода, они поразительно отличаются. "После" тесты гораздо больше озабочены деталями реализации класса и обеспечением хорошего покрытия строк, в то время как "перед" тесты больше о проверке желаемого внешнего поведения. Это именно то, что нас интересует с unit тестами в любом случае, - убедиться, что класс демонстрирует правильное поведение. Тесты, ориентированные на реализацию, на самом деле затрудняют рефакторинг, потому что они ломаются, если внутренности классов изменяются, и вы только что лишили себя преимуществ сокрытия информации от OOP.

### 5.4 Что делает хороший unit тест

Хорошие unit тесты делят много следующих характеристик:

*   Быстрые - должны запускаться в миллисекундах.
*   Без доступа к сети - должны уметь отключить беспроводную связь/вытащить шнур и все тесты все равно проходят.
*   Ограниченный доступ к файловой системе - это добавляет к скорости и гибкости при развертывании кода в другие среды.
*   Без доступа к базе данных - избегает costly setup и teardown деятельности.
*   Тестировать только одну вещь за раз - unit тест должен иметь только одну причину для неудачи.
*   Хорошо названные - см. 5.2 выше.
*   В основном фейковые объекты - единственные "реальные" объекты в unit тестах должны быть объектом, который мы тестируем, и простыми объектами значений. Остальное должно быть какой-то формой [test double](https://phpunit.de/manual/current/en/test-doubles.html)

Есть причины пойти против некоторых из них, но как общие рекомендации они послужат вам хорошо.

### 5.5 Когда тестирование болезненно

> Unit testing заставляет вас почувствовать боль плохого дизайна спереди - Michael Feathers

Когда вы пишете unit тесты, вы заставляете себя фактически использовать класс для достижения вещей. Если вы пишете тесты в конце или, что хуже, просто бросаете код через стену для QA или кого-то, чтобы написать тесты, вы не получаете никакой обратной связи о том, как класс на самом деле себя ведет. Если мы пишем тесты и класс - настоящая боль в использовании, мы узнаем об этом, пока пишем его, что почти самое дешевое время, чтобы исправить это.

Если класс трудно протестировать, это flaw дизайна. Разные недостатки проявляют себя по-разному, хотя. Если вам приходится делать тонну mocking, ваш класс, вероятно, имеет слишком много зависимостей или ваши методы делают слишком много. Чем больше настройки вам приходится делать для каждого теста, тем больше вероятность, что ваши методы делают слишком много. Если вам приходится писать очень запутанные сценарии тестов, чтобы проверить поведение, методы класса, вероятно, делают слишком много. Если вам приходится копаться внутри кучи приватных методов и состояния, чтобы протестировать вещи, возможно, другой класс пытается выбраться. Unit testing очень хорош в разоблачении "iceberg классов", где 80% того, что делает класс, спрятано в защищенном или приватном коде. Раньше я был большим поклонником делать как можно больше защищенным, но теперь я понял, что просто делал свои индивидуальные классы responsible за слишком многое, и настоящее решение - разбить класс на меньшие куски.

> **Написано Brian Fenton** - Brian Fenton - PHP-разработчик в течение 8 лет в Среднем Западе и Bay Area, в настоящее время в Thismoment. Он фокусируется на craftsmanship кода и принципах дизайна. Блог на www.brianfenton.us, Twitter на @brianfenton. Когда он не занят отцом, он наслаждается едой, пивом, играми и обучением.